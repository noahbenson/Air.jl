<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Full Air API Reference · Air.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Air.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../parray/">Persistent Arrays</a></li><li><a class="tocitem" href="../pdict/">Persistent Dictionaries</a></li><li><a class="tocitem" href="../pset/">Persistent Sets</a></li><li><a class="tocitem" href="../pwdict/">Persistent Weighted Dictionaries</a></li><li><a class="tocitem" href="../pwset/">Persistent Weighted Sets</a></li><li><a class="tocitem" href="../lazydict/">Persistent Lazy Dictionaries</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>The Full Air API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The Full Air API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/noahbenson/Air.jl/blob/master/docs/src/API.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-Full-Air-API-Reference"><a class="docs-heading-anchor" href="#The-Full-Air-API-Reference">The Full Air API Reference</a><a id="The-Full-Air-API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#The-Full-Air-API-Reference" title="Permalink"></a></h1><p>This pagee contains the full API documentation for Air. This includes both the documentation for public and private objects.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Air.TX_MAX_ATTEMPTS"><code>Air.TX_MAX_ATTEMPTS</code></a></li><li><a href="#Air.airout"><code>Air.airout</code></a></li><li><a href="#Air.current_tx"><code>Air.current_tx</code></a></li><li><a href="#Air.AbstractPArray"><code>Air.AbstractPArray</code></a></li><li><a href="#Air.AbstractPDict"><code>Air.AbstractPDict</code></a></li><li><a href="#Air.AbstractPSet"><code>Air.AbstractPSet</code></a></li><li><a href="#Air.AbstractPWDict"><code>Air.AbstractPWDict</code></a></li><li><a href="#Air.AbstractPWSet"><code>Air.AbstractPWSet</code></a></li><li><a href="#Air.Actor"><code>Air.Actor</code></a></li><li><a href="#Air.ActorException"><code>Air.ActorException</code></a></li><li><a href="#Air.ActorMsg"><code>Air.ActorMsg</code></a></li><li><a href="#Air.ActorTxData"><code>Air.ActorTxData</code></a></li><li><a href="#Air.AirOut"><code>Air.AirOut</code></a></li><li><a href="#Air.Delay"><code>Air.Delay</code></a></li><li><a href="#Air.LazyDict"><code>Air.LazyDict</code></a></li><li><a href="#Air.LazyIdDict"><code>Air.LazyIdDict</code></a></li><li><a href="#Air.PArray"><code>Air.PArray</code></a></li><li><a href="#Air.PDict"><code>Air.PDict</code></a></li><li><a href="#Air.PHeap"><code>Air.PHeap</code></a></li><li><a href="#Air.PIdDict"><code>Air.PIdDict</code></a></li><li><a href="#Air.PIdLinearDict"><code>Air.PIdLinearDict</code></a></li><li><a href="#Air.PIdLinearSet"><code>Air.PIdLinearSet</code></a></li><li><a href="#Air.PIdSet"><code>Air.PIdSet</code></a></li><li><a href="#Air.PLinearDict"><code>Air.PLinearDict</code></a></li><li><a href="#Air.PLinearSet"><code>Air.PLinearSet</code></a></li><li><a href="#Air.PMatrix"><code>Air.PMatrix</code></a></li><li><a href="#Air.PSet"><code>Air.PSet</code></a></li><li><a href="#Air.PTree"><code>Air.PTree</code></a></li><li><a href="#Air.PVector"><code>Air.PVector</code></a></li><li><a href="#Air.PWDict"><code>Air.PWDict</code></a></li><li><a href="#Air.PWIdDict"><code>Air.PWIdDict</code></a></li><li><a href="#Air.PWIdSet"><code>Air.PWIdSet</code></a></li><li><a href="#Air.PWSet"><code>Air.PWSet</code></a></li><li><a href="#Air.Promise"><code>Air.Promise</code></a></li><li><a href="#Air.ReentrantRef"><code>Air.ReentrantRef</code></a></li><li><a href="#Air.Transaction"><code>Air.Transaction</code></a></li><li><a href="#Air.TransactionalRef"><code>Air.TransactionalRef</code></a></li><li><a href="#Air.TxIO"><code>Air.TxIO</code></a></li><li><a href="#Air.TxRetryException"><code>Air.TxRetryException</code></a></li><li><a href="#Air.Var"><code>Air.Var</code></a></li><li><a href="#Air.VarsDict"><code>Air.VarsDict</code></a></li><li><a href="#Air.Volatile"><code>Air.Volatile</code></a></li><li><a href="#Air.actor_main-Union{Tuple{Actor{T}}, Tuple{T}} where T"><code>Air.actor_main</code></a></li><li><a href="#Air.actor_reset-Union{Tuple{S}, Tuple{T}, Tuple{Actor{T}, S}} where {T, S}"><code>Air.actor_reset</code></a></li><li><a href="#Air.actor_reset!-Union{Tuple{T}, Tuple{Actor{T}, Any}} where T"><code>Air.actor_reset!</code></a></li><li><a href="#Air.actor_send-Union{Tuple{T}, Tuple{Actor{T}, Air.ActorMsg}} where T"><code>Air.actor_send</code></a></li><li><a href="#Air.actor_send!-Union{Tuple{T}, Tuple{Actor{T}, Air.ActorMsg}} where T"><code>Air.actor_send!</code></a></li><li><a href="#Air.actor_start-Union{Tuple{Actor{T}}, Tuple{T}} where T"><code>Air.actor_start</code></a></li><li><a href="#Air.actor_start!-Union{Tuple{Actor{T}}, Tuple{T}} where T"><code>Air.actor_start!</code></a></li><li><a href="#Air.actor_value-Union{Tuple{Actor{T}}, Tuple{T}} where T"><code>Air.actor_value</code></a></li><li><a href="#Air.currtx-Tuple{}"><code>Air.currtx</code></a></li><li><a href="#Air.delete-Union{Tuple{J}, Tuple{V}, Tuple{K}, Tuple{AbstractDict{K, V}, J}} where {K, V, J}"><code>Air.delete</code></a></li><li><a href="#Air.depth_to_bitshift-Tuple{Integer}"><code>Air.depth_to_bitshift</code></a></li><li><a href="#Air.equalfn-Tuple{T} where T"><code>Air.equalfn</code></a></li><li><a href="#Air.geterror-Union{Tuple{Actor{T}}, Tuple{T}} where T"><code>Air.geterror</code></a></li><li><a href="#Air.getfilter-Union{Tuple{Volatile{T}}, Tuple{T}} where T"><code>Air.getfilter</code></a></li><li><a href="#Air.getfinalize-Union{Tuple{Volatile{T}}, Tuple{T}} where T"><code>Air.getfinalize</code></a></li><li><a href="#Air.getpair"><code>Air.getpair</code></a></li><li><a href="#Air.getweight-Union{Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T, W, F, D}, S}} where {T, W, F, D, S}"><code>Air.getweight</code></a></li><li><a href="#Air.hashfn-Tuple{T} where T"><code>Air.hashfn</code></a></li><li><a href="#Air.highmask-Union{Tuple{K}, Tuple{T}, Tuple{K, Type{T}}} where {T&lt;:Unsigned, K&lt;:Integer}"><code>Air.highmask</code></a></li><li><a href="#Air.insert"><code>Air.insert</code></a></li><li><a href="#Air.lockall"><code>Air.lockall</code></a></li><li><a href="#Air.lowmask-Union{Tuple{K}, Tuple{T}, Tuple{K, Type{T}}} where {T&lt;:Unsigned, K&lt;:Integer}"><code>Air.lowmask</code></a></li><li><a href="#Air.pfill-Union{Tuple{T}, Tuple{T, Vararg{Integer, N} where N}} where T"><code>Air.pfill</code></a></li><li><a href="#Air.pones-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any, N} where N}} where T"><code>Air.pones</code></a></li><li><a href="#Air.pop"><code>Air.pop</code></a></li><li><a href="#Air.popat"><code>Air.popat</code></a></li><li><a href="#Air.popfirst"><code>Air.popfirst</code></a></li><li><a href="#Air.ptree_bitshift-Tuple{UInt64}"><code>Air.ptree_bitshift</code></a></li><li><a href="#Air.ptree_cellindex-Tuple{UInt64, UInt64, UInt64}"><code>Air.ptree_cellindex</code></a></li><li><a href="#Air.ptree_cellindex!-Tuple{UInt64, UInt64, UInt64}"><code>Air.ptree_cellindex!</code></a></li><li><a href="#Air.ptree_cellkey-Tuple{UInt64, UInt64}"><code>Air.ptree_cellkey</code></a></li><li><a href="#Air.ptree_depth-Tuple{UInt64}"><code>Air.ptree_depth</code></a></li><li><a href="#Air.ptree_firstbit-Tuple{UInt64}"><code>Air.ptree_firstbit</code></a></li><li><a href="#Air.ptree_highbitdiff-Tuple{UInt64, UInt64}"><code>Air.ptree_highbitdiff</code></a></li><li><a href="#Air.ptree_id-Tuple{Integer, Integer}"><code>Air.ptree_id</code></a></li><li><a href="#Air.ptree_isbeneath-Tuple{UInt64, UInt64}"><code>Air.ptree_isbeneath</code></a></li><li><a href="#Air.ptree_maxleaf-Tuple{UInt64}"><code>Air.ptree_maxleaf</code></a></li><li><a href="#Air.ptree_minleaf-Tuple{UInt64}"><code>Air.ptree_minleaf</code></a></li><li><a href="#Air.ptree_minmaxleaf-Tuple{UInt64}"><code>Air.ptree_minmaxleaf</code></a></li><li><a href="#Air.ptree_parentid-Tuple{UInt64}"><code>Air.ptree_parentid</code></a></li><li><a href="#Air.ptree_shift-Tuple{UInt64}"><code>Air.ptree_shift</code></a></li><li><a href="#Air.push"><code>Air.push</code></a></li><li><a href="#Air.pushfirst"><code>Air.pushfirst</code></a></li><li><a href="#Air.pzeros-Union{Tuple{T}, Tuple{Type{T}, Vararg{Integer, N} where N}} where T"><code>Air.pzeros</code></a></li><li><a href="#Air.reset-Union{Tuple{S}, Tuple{T}, Tuple{Actor{T}, S}} where {T, S}"><code>Air.reset</code></a></li><li><a href="#Air.send-Union{Tuple{T}, Tuple{Function, Actor{T}}} where T"><code>Air.send</code></a></li><li><a href="#Air.setfilter!-Union{Tuple{T}, Tuple{Volatile{T}, Function}} where T"><code>Air.setfilter!</code></a></li><li><a href="#Air.setfinalize!-Union{Tuple{T}, Tuple{Volatile{T}, Function}} where T"><code>Air.setfinalize!</code></a></li><li><a href="#Air.setvars"><code>Air.setvars</code></a></li><li><a href="#Air.setweight-Union{Tuple{X}, Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T, W, F, D}, S, X}} where {T, W, F, D, S, X&lt;:Number}"><code>Air.setweight</code></a></li><li><a href="#Air.take-Union{Tuple{Promise{T}}, Tuple{T}} where T"><code>Air.take</code></a></li><li><a href="#Air.tx-Tuple{F} where F&lt;:Function"><code>Air.tx</code></a></li><li><a href="#Air.tx_actordata-Union{Tuple{Actor{T}}, Tuple{T}} where T"><code>Air.tx_actordata</code></a></li><li><a href="#Air.vars"><code>Air.vars</code></a></li><li><a href="#Air.voldata_finalize-Union{Tuple{Air.VolatileData{T}}, Tuple{T}} where T"><code>Air.voldata_finalize</code></a></li><li><a href="#Air.withvars"><code>Air.withvars</code></a></li><li><a href="#Air.wrapsetvars"><code>Air.wrapsetvars</code></a></li><li><a href="#Air.wrapwithvars"><code>Air.wrapwithvars</code></a></li><li><a href="#Air.@delay-Tuple{Expr}"><code>Air.@delay</code></a></li><li><a href="#Air.@memoize-Tuple{Expr}"><code>Air.@memoize</code></a></li><li><a href="#Air.@p-Tuple"><code>Air.@p</code></a></li><li><a href="#Air.@tx-Tuple{Any}"><code>Air.@tx</code></a></li><li><a href="#Air.@var-Tuple{Expr}"><code>Air.@var</code></a></li></ul><h2 id="API-Documents"><a class="docs-heading-anchor" href="#API-Documents">API Documents</a><a id="API-Documents-1"></a><a class="docs-heading-anchor-permalink" href="#API-Documents" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Air.TX_MAX_ATTEMPTS" href="#Air.TX_MAX_ATTEMPTS"><code>Air.TX_MAX_ATTEMPTS</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">TX_MAX_ATTEMPTS</code></pre><p>The maximum number of retry attempts that a transaction will make before aborting the transaction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL608-L613">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.airout" href="#Air.airout"><code>Air.airout</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">airout</code></pre><p>The <code>airout</code> object is a <code>AirOut</code> object that wraps the <code>stdout</code> object.</p><p>See also: <a href="#Air.AirOut"><code>AirOut</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL1140-L1146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.current_tx" href="#Air.current_tx"><code>Air.current_tx</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">current_tx</code></pre><p>The <code>current_tx</code> constant is a <code>Var{T}</code> that stores the current task&#39;s running <code>Transaction</code>, or <code>nothing</code> if there is no transaction running.</p><p>See also: <a href="#Air.currtx-Tuple{}"><code>currtx</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL571-L578">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.AbstractPArray" href="#Air.AbstractPArray"><code>Air.AbstractPArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractPArray{T,N}</code></pre><p>The Abstract persistent array type represents any <code>Array</code>-like type that is persistent. The Air library provides the reified type <code>PArray{T,N}</code>.</p><p>See also: <a href="#Air.PArray"><code>PArray</code></a>, <a href="#Air.PVector"><code>PVector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/api.jl#LL38-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.AbstractPDict" href="#Air.AbstractPDict"><code>Air.AbstractPDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractPDict{K,V}</code></pre><p><code>AbstractPDict</code> is a subtype of <code>AbstractDict</code> that is extended only by persistent dictionary types such as <code>PDict</code> and <code>LazyDict</code>.</p><p>See also <a href="#Air.PDict"><code>PDict</code></a>, <a href="#Air.PWDict"><code>PWDict</code></a>, <a href="#Air.LazyDict"><code>LazyDict</code></a>, <a href="#Air.PIdDict"><code>PIdDict</code></a>, <a href="#Air.LazyIdDict"><code>LazyIdDict</code></a>, <a href="#Air.PWIdDict"><code>PWIdDict</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/api.jl#LL19-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.AbstractPSet" href="#Air.AbstractPSet"><code>Air.AbstractPSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractPSet{T}</code></pre><p><code>AbstractPSet</code> is an abstract type extended by persistent set types such as  <code>PSet</code> and `PWSet.</p><p>See also: <a href="#Air.PSet"><code>PSet</code></a>, <a href="#Air.PIdSet"><code>PIdSet</code></a>, <a href="#Air.PWSet"><code>PWSet</code></a>, <a href="#Air.PWIdSet"><code>PWIdSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/api.jl#LL29-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.AbstractPWDict" href="#Air.AbstractPWDict"><code>Air.AbstractPWDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractPWDict</code></pre><p>AbstractPWDict is a subtype of AbstractPDict that is overloaded by classes that represent weighted persistent dictionaries.</p><p>See also: <a href="#Air.AbstractPDict"><code>AbstractPDict</code></a>, <a href="#Air.PWDict"><code>PWDict</code></a>, <a href="#Air.AbstractPWSet"><code>AbstractPWSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/pwdict.jl#LL15-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.AbstractPWSet" href="#Air.AbstractPWSet"><code>Air.AbstractPWSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractPWSet{T,W}</code></pre><p>AbstractPWSet is an abstract type implemented by all persistent weighted set types.</p><p>See also: <a href="#Air.PWSet"><code>PWSet</code></a>, <a href="#Air.AbstractPSet"><code>AbstractPSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/pwset.jl#LL15-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.Actor" href="#Air.Actor"><code>Air.Actor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Actor{T}</code></pre><p>An actor is an object that represents a worker-thread to which tasks can be scheduled. Any scheduled function is guaranteed to be evaluated at some point in the future in some other thread, and the return value of that function will become the new value held by the actor. Each function, when it is run, is passed the actor&#39;s value as one of its argument.</p><p>Like with <code>Ref</code>s, you can access an actor&#39;s current value using <code>getindex</code>,  e.g., <code>actor[]</code>. Within a transaction, this will be guaranteed to remain fixed for the duration of the transaction; outside of a transaction, this may change at arbitrary times.</p><p><code>Actor</code>s may be initialized with post-processing functions. These functions are called immediately after executing any scheduled function and are given as their first argument the original actor value and as their second argument the return value of the scheduled function. Instead of saving this return value, the return value of the post-processing function is saved in the actor. This is useful for actors whose job is, for example, to serialize output to a log file being written to across many threads. If we run something like  <code>send(println, log_actor, &quot;Some log message&quot;)</code> the <code>println</code> function will return <code>nothing</code>, which we would like to convert back into the log stream so that subsequent <code>send</code> calls can continue to use the <code>println</code> fuction.</p><p>Actors may additionally be given an error handler. Whenever an exception occurs during a scheduled function, the error handler will be called with the arguments of (1) the actor object, (2) the current actor value, and (3) the exception that was caught. When an error has occurred, any attempt to schedule a function to the actor or to read from the actor will cause an exception to be raised. The error may be examined using <code>geterror(actor)</code> and restarted using <code>reset(actor)</code>.</p><p>All fields in an actor object should be considered strictly private. These fields are likely to change between releases, and changing the values will break your code.</p><p>See also: <a href="#Air.tx-Tuple{F} where F&lt;:Function"><code>tx</code></a>, <a href="#Air.@tx-Tuple{Any}"><code>@tx</code></a>, <a href="#Air.send-Union{Tuple{T}, Tuple{Function, Actor{T}}} where T"><code>send</code></a>, <a href="#Air.geterror-Union{Tuple{Actor{T}}, Tuple{T}} where T"><code>geterror</code></a>, <a href="#Air.reset-Union{Tuple{S}, Tuple{T}, Tuple{Actor{T}, S}} where {T, S}"><code>reset</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; a = Actor{Symbol}(:start_sym)
Actor{Symbol}(@JIm7aUS2sOl: :start_sym)

julia&gt; send(a) do val; sleep(0.1); Symbol(&quot;new_$(val)&quot;) end
Actor{Symbol}(@JIm7aUS2sOl: :start_sym)

julia&gt; sleep(1); a[]
:new_start_sym</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL63-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ActorException" href="#Air.ActorException"><code>Air.ActorException</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ActorException{T}(error, value, argno, args)</code></pre><p>An ActorException object is thrown whenever one attempts to obtain the value of or send a function to an actor that is in an error state. An error state occurs when an unhandled exception is raised while an actor is processing a sent function. In such a case the <code>geterror()</code> and <code>restart()</code> functions may be used. The <code>geterror()</code> function yields an <code>ActorException</code> object in which the exception that was raised is stored as <code>error</code>, the value of the actor when the send was run is stored in <code>value</code>, and the <code>args</code> and <code>argno</code> give the full contex of the <code>send</code> call (i.e., the fucntion followed by the arguments is <code>args</code> and the argument number that corresponds to the actor is <code>argno</code>).</p><p>See also: <a href="#Air.Actor"><code>Actor</code></a>, <a href="#Air.geterror-Union{Tuple{Actor{T}}, Tuple{T}} where T"><code>geterror</code></a>, <a href="#Air.reset-Union{Tuple{S}, Tuple{T}, Tuple{Actor{T}, S}} where {T, S}"><code>reset</code></a>, <a href="#Air.send-Union{Tuple{T}, Tuple{Function, Actor{T}}} where T"><code>send</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL34-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ActorMsg" href="#Air.ActorMsg"><code>Air.ActorMsg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ActorMsg</code></pre><p>A message, queued for an <code>Actor</code> via the <code>send()</code> function.</p><p>The <code>ActorMsg</code> struct is considered part of <code>Air</code>&#39;s private/internal implementation details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL22-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ActorTxData" href="#Air.ActorTxData"><code>Air.ActorTxData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ActorTxData{T}</code></pre><p>The data tracked for an <code>Actor{T}</code> during a transaction by the transaction&#39;s  <code>Transaction</code> struct.</p><p>The <code>ActorTxData</code> struct is considered part of the internal/private code of Air and generally should not be used outside of the Air library.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL491-L499">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.AirOut" href="#Air.AirOut"><code>Air.AirOut</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AirOut</code></pre><p>The <code>AirOut</code> type is a derivative of the <code>IO</code> class and is intended for handling output to <code>stdout</code> across multiple threads in a thread-safe way. It is similar <code>TxIO</code> except that it only writes to <code>stdout</code> and is only really intended for use with the <code>airout</code> object.</p><p>See also: <a href="#Air.Actor"><code>Actor</code></a>, <a href="#Air.airout"><code>airout</code></a>, <a href="#Air.TxIO"><code>TxIO</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL1102-L1111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.Delay" href="#Air.Delay"><code>Air.Delay</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Delay{T}</code></pre><p><code>Delay</code> objects can be used to lazily calculate a single value the first time it is requested. They act like <code>Ref</code>s in that you access a delay <code>d</code> via <code>d[]</code>. <code>Delay</code> objects are thread-safe and are functionally immutable.</p><p>See also: <a href="#Air.@delay-Tuple{Expr}"><code>@delay</code></a>, <a href="#Air.LazyDict"><code>LazyDict</code></a></p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; # Create a Delay with a long run time.
       d = Delay{Int64}(() -&gt; (println(&quot;Running.&quot;); sleep(2); 10))
Delay{Int64}(&lt;...&gt;)

julia&gt; # Start a few threads, each of which attempt to read it. The function
       # will only run once.
       for th in [(Threads.@spawn d[]) for _ in 1:5]; wait(th) end
Running.

julia&gt; # Ensure that it produced the correct value and doesn&#39;t run again.
       d[]
10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/util.jl#LL17-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.LazyDict" href="#Air.LazyDict"><code>Air.LazyDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LazyDict{K,V}</code></pre><p>A dictionay type equivalent to <code>PDict{K,V}</code> in every way except that for any value in the dict that is a <code>Delay</code> object, the dictionary hides the delay and always returns the delay&#39;s value. This allows any value that has not yet been requested to be lazily unevaluated.</p><p>See also: <a href="#Air.PDict"><code>PDict</code></a>, <code>Base.Dict</code>, <a href="#Air.LazyIdDict"><code>LazyIdDict</code></a>, <a href="#Air.Delay"><code>Delay</code></a>, <a href="#Air.@delay-Tuple{Expr}"><code>@delay</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; LazyDict()
LazyDict{Any,Any}()</code></pre><pre><code class="language-julia-repl">julia&gt; LazyDict(:a =&gt; 1, :b =&gt; 2, :c =&gt; 12.8)
LazyDict{Symbol,Real} with 3 entries:
  :c =&gt; 12.8
  :a =&gt; 1
  :b =&gt; 2</code></pre><pre><code class="language-julia-repl">julia&gt; d = LazyDict{Symbol,Float64}(:a =&gt; 1, :b =&gt; 2, :c =&gt; 12.8)
LazyDict{Symbol,Float64} with 3 entries:
  :c =&gt; 12.8
  :a =&gt; 1.0
  :b =&gt; 2.0

julia&gt; d2 = push(d, :d =&gt; Delay{Real}(() -&gt; (println(&quot;Running...&quot;); 0.5))); haskey(d2, :d)
true

julia&gt; d2[:d]
Running...
0.5

julia&gt; d2[:d]
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/lazydict.jl#LL158-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.LazyIdDict" href="#Air.LazyIdDict"><code>Air.LazyIdDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LazyIdDict{K,V}</code></pre><p>A dictionay type equivalent to <code>PIdDict{K,V}</code> in every way except that for any value in the dict that is a <code>Delay</code> object, the dictionary hides the delay and always returns the delay&#39;s value. This allows any value that has not yet been requested to be lazily unevaluated.</p><p>See also: <a href="#Air.PIdDict"><code>PIdDict</code></a>, <code>Base.IdDict</code>, <a href="#Air.LazyDict"><code>LazyDict</code></a>, <a href="#Air.Delay"><code>Delay</code></a>, <a href="#Air.@delay-Tuple{Expr}"><code>@delay</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; LazyIdDict()
LazyIdDict{Any,Any}()</code></pre><pre><code class="language-julia-repl">julia&gt; LazyIdDict(:a =&gt; 1, :b =&gt; 2, :c =&gt; 12.8)
LazyIdDict{Symbol,Real} with 3 entries:
  :b =&gt; 2
  :a =&gt; 1
  :c =&gt; 12.8</code></pre><pre><code class="language-julia-repl">julia&gt; d = LazyIdDict{Symbol,Float64}(:a =&gt; 1, :b =&gt; 2, :c =&gt; 12.8)
LazyIdDict{Symbol,Float64} with 3 entries:
  :b =&gt; 2.0
  :a =&gt; 1.0
  :c =&gt; 12.8

julia&gt; d2 = push(d, :d =&gt; Delay{Real}(() -&gt; (println(&quot;Running...&quot;); 0.5)));

julia&gt; haskey(d2, :d)
true

julia&gt; d2[:d]
Running...
0.5

julia&gt; d2[:d]
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/lazydict.jl#LL208-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PArray" href="#Air.PArray"><code>Air.PArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PArray{T,N}</code></pre><p>The PArray type is a persistent/immutable corrolary to the Array{T,N} type. Like Array, PArray can store n-dimensional non-ragged arrays. However, unlike Arrays, PArrays can create duplicates of themselves with finite edits in log-time.</p><p>PArrays have a similar interface as Arrays, but instead of the functions <code>push!</code>, <code>pop!</code>, and <code>setindex!</code>, PArrays use <code>push</code>, <code>pop</code>, and <code>setindex</code>. PArrays also have efficient implementations of <code>pushfirst</code> and <code>popfirst</code>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; PArray()
0-element PArray{Any,1}</code></pre><pre><code class="language-julia-repl">julia&gt; u = PArray{Int,1}([1,2])
2-element PArray{Int64,1}:
 1
 2

julia&gt; push(u, 3)
3-element PArray{Int64,1}:
 1
 2
 3</code></pre><pre><code class="language-julia-repl">julia&gt; PArray{Symbol,2}(:abc, (2,3))
2×3 PArray{Symbol,2}:
 :abc  :abc  :abc
 :abc  :abc  :abc</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/parray.jl#LL32-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PDict" href="#Air.PDict"><code>Air.PDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PDict{K,V}</code></pre><p>A dictionay type roughly equivalent to <code>Dict{K,V}</code> but that stores data using a persistent hash array mapped trie system that allows for efficient persistent operations. These operations are represented by non-mutating versions of the standard dictionary functions, such as <code>setindex</code> in place of <code>setindex!</code>, <code>push</code> in place of <code>push!</code>, and <code>pop</code> in place of <code>pop!</code>. These operations are performed in <code>O(log n)</code> time, and minimal data duplication is performed in  update operations.</p><p>See also: <a href="#Air.PIdDict"><code>PIdDict</code></a>, <code>Dict</code>, <a href="#Air.push"><code>push</code></a>, <a href="#Air.pop"><code>pop</code></a>, <a href="#Base.setindex-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, S, Vararg{Any, N} where N}} where {T, N, S}"><code>setindex</code></a>, <a href="#Air.delete-Union{Tuple{J}, Tuple{V}, Tuple{K}, Tuple{AbstractDict{K, V}, J}} where {K, V, J}"><code>delete</code></a>, <a href="#Air.insert"><code>insert</code></a>, <a href="#Air.getpair"><code>getpair</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; PDict()
PDict{Any,Any}()</code></pre><pre><code class="language-julia-repl">julia&gt; PDict(:a =&gt; 1, :b =&gt; 2, :c =&gt; 12.8)
PDict{Symbol,Real} with 3 entries:
  :c =&gt; 12.8
  :a =&gt; 1
  :b =&gt; 2</code></pre><pre><code class="language-julia-repl">julia&gt; d = PDict{Symbol,Float64}(:a =&gt; 1, :b =&gt; 2, :c =&gt; 12.8)
PDict{Symbol,Float64} with 3 entries:
  :c =&gt; 12.8
  :a =&gt; 1.0
  :b =&gt; 2.0

julia&gt; :b in keys(d)
true

julia&gt; d[:c]
12.8

julia&gt; push(d, :d =&gt; 0.1)
PDict{Symbol,Float64} with 4 entries:
  :d =&gt; 0.1
  :c =&gt; 12.8
  :a =&gt; 1.0
  :b =&gt; 2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/pdict.jl#LL318-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PHeap" href="#Air.PHeap"><code>Air.PHeap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PHeap{T,W,F}</code></pre><p>A <code>PHeap</code> object is a priority queue to which objects can be <code>push</code>ed and given a particular weight. <code>PHeap</code>s can then be <code>iterate</code>d in weighted order, <code>pop</code>ped in weighted order, and the <code>first</code>  element may be obtained in weighted order. Additionally, a random sample may be drawn from a heap, which uses the distribution implied by the relative weights of the items in the heap.</p><p><code>PHeap</code> objects may be initialized with a single argument of type <code>F &lt;: Function</code>, in which case this function is used to compare the weights for ordering. By default this is <code>&gt;</code> such that high weights are retrieved first by the <code>first()</code> function and removed first by the <code>pop()</code> function. Note, however, that the relative weights are still used by the <code>rand</code> function regardless of the ordering function, so negative values cannot be used.</p><p>See also: <a href="#Air.PWSet"><code>PWSet</code></a>, <a href="#Air.PWDict"><code>PWDict</code></a>, <a href="#Air.pop"><code>pop</code></a>, <code>Base.first</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/pheap.jl#LL16-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PIdDict" href="#Air.PIdDict"><code>Air.PIdDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PIdDict{K,V}</code></pre><p>A dictionay type roughly equivalent to <code>IdDict{K,V}</code> but that stores data using a persistent hash array mapped trie system that allows for efficient persistent operations. These operations are represented by non-mutating versions of the standard dictionary functions, such as <code>setindex</code> in place of <code>setindex!</code>, <code>push</code> in place of <code>push!</code>, and <code>pop</code> in place of <code>pop!</code>. These operations are performed in <code>O(log n)</code> time, and minimal data duplication is performed in  update operations.</p><p>See also: <a href="#Air.PDict"><code>PDict</code></a>, <code>Base.IdDict</code>, <a href="#Air.push"><code>push</code></a>, <a href="#Air.pop"><code>pop</code></a>, <a href="#Base.setindex-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, S, Vararg{Any, N} where N}} where {T, N, S}"><code>setindex</code></a>, <a href="#Air.delete-Union{Tuple{J}, Tuple{V}, Tuple{K}, Tuple{AbstractDict{K, V}, J}} where {K, V, J}"><code>delete</code></a>, <a href="#Air.insert"><code>insert</code></a>, <a href="#Air.getpair"><code>getpair</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; PIdDict()
PIdDict{Any,Any}()
</code></pre><p>jldoctest; filter=r&quot;PIdDict{Symbol, ?Real} with 3 entries:&quot; julia&gt; PIdDict(:a =&gt; 1, :b =&gt; 2, :c =&gt; 12.8) PIdDict{Symbol,Real} with 3 entries:   :c =&gt; 12.8   :a =&gt; 1   :b =&gt; 2</p><pre><code class="language-none"></code></pre><p>jldoctest; filter=r&quot;PIdDict{Symbol, ?Float64} with [34] entries:&quot; julia&gt; d = PIdDict{Symbol,Float64}(:a =&gt; 1, :b =&gt; 2, :c =&gt; 12.8) PIdDict{Symbol,Float64} with 3 entries:   :c =&gt; 12.8   :a =&gt; 1.0   :b =&gt; 2.0</p><p>julia&gt; :b in keys(d) true</p><p>julia&gt; d[:c] 12.8</p><p>julia&gt; push(d, :d =&gt; 0.1) PIdDict{Symbol,Float64} with 4 entries:   :d =&gt; 0.1   :c =&gt; 12.8   :a =&gt; 1.0   :b =&gt; 2.0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/pdict.jl#LL374-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PIdLinearDict" href="#Air.PIdLinearDict"><code>Air.PIdLinearDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PIdLinearDict{K,V}</code></pre><p>An identity-based persistent dict type that uses a simple array representation internally; accordingly <code>PIdLinearDict</code> does not peform persistent operations such as <code>setindex</code>, <code>push</code>, and <code>delete</code> efficiently. It is intended to be used by Air internally as a sub-dict that stores items whose hash values are identical.</p><p>See also: <a href="#Air.PLinearDict"><code>PLinearDict</code></a>, <a href="#Air.PIdDict"><code>PIdDict</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/pdict.jl#LL181-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PIdLinearSet" href="#Air.PIdLinearSet"><code>Air.PIdLinearSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PIdLinearSet{T}</code></pre><p>A persistent <code>IdSet</code> type that uses a simple array representation internally; accordingly <code>PIdLinearSet</code> does not peform persistent operations such as <code>setindex</code>, <code>push</code>, and <code>delete</code> efficiently. It is intended to be used by Air internally as a set that stores items whose hash values are identical.</p><p>See also: <a href="#Air.PLinearSet"><code>PLinearSet</code></a>, <a href="#Air.PSet"><code>PSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/pset.jl#LL160-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PIdSet" href="#Air.PIdSet"><code>Air.PIdSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PIdSet{T}</code></pre><p>A persistent identity-based set type that uses an array hash-mapped trie structure to allow for efficient updating of the set using the persistent operations defined by Air such as <code>push</code>, and <code>delete</code>.</p><p>See also: <code>Set</code>, <a href="#Air.PIdSet"><code>PIdSet</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; PIdSet()
PIdSet{Any}()

julia&gt; :a in PIdSet([:a, :b, :c])
true

julia&gt; :d in PIdSet([:a, :b, :c])
false

julia&gt; :d in push(PIdSet(), :d)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/pset.jl#LL301-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PLinearDict" href="#Air.PLinearDict"><code>Air.PLinearDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PLinearDict{K,V}</code></pre><p>A persistent dict type that uses a simple array representation internally; accordingly <code>PLinearDict</code> does not peform persistent operations such as <code>setindex</code>, <code>push</code>, and <code>delete</code> efficiently. It is intended to be used by Air internally as a sub-dict that stores items whose hash values are identical.</p><p>See also: <a href="#Air.PIdLinearDict"><code>PIdLinearDict</code></a>, <a href="#Air.PDict"><code>PDict</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/pdict.jl#LL171-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PLinearSet" href="#Air.PLinearSet"><code>Air.PLinearSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PLinearSet{T}</code></pre><p>A persistent set type that uses a simple array representation internally; accordingly <code>PLinearSet</code> does not peform persistent operations such as <code>setindex</code>, <code>push</code>, and <code>delete</code> efficiently. It is intended to be used by Air internally as a set that stores items whose hash values are identical.</p><p>See also: <a href="#Air.PIdLinearSet"><code>PIdLinearSet</code></a>, <a href="#Air.PSet"><code>PSet</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/pset.jl#LL149-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PMatrix" href="#Air.PMatrix"><code>Air.PMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PMatrix{T}</code></pre><p>An alias for <code>PArray{T,2}</code>, representing a persistent matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/parray.jl#LL142-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PSet" href="#Air.PSet"><code>Air.PSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PSet{T}</code></pre><p>A persistent set type that uses an array hash-mapped trie structure to allow for efficient updating of the set using the persistent operations defined by Air such as <code>setindex</code>, <code>push</code>, and <code>delete</code>.</p><p>See also: <code>Set</code>, <a href="#Air.PIdSet"><code>PIdSet</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; PSet()
PSet{Any}()

julia&gt; :a in PSet([:a, :b, :c])
true

julia&gt; :d in PSet([:a, :b, :c])
false

julia&gt; :d in push(PSet(), :d)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/pset.jl#LL270-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PTree" href="#Air.PTree"><code>Air.PTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PTree{T}</code></pre><p>PTree is a persistent tree/array hybrid that maps arbitrary unsigned integers (type HASH_T) to values. It can efficiently be used for arrays or for hash-maps, and supports efficient lookup, association, and dissociation.</p><p>All fields of a PTree should be considered strictly private, as modification of the fields may result in a kernel crash. The properties of a PTree are both immutable and safe to inpect.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/ptree.jl#LL210-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PVector" href="#Air.PVector"><code>Air.PVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PVector{T}</code></pre><p>An alias for <code>PArray{T,1}</code>, representing a persistent vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/parray.jl#LL128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PWDict" href="#Air.PWDict"><code>Air.PWDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PWDict{K,V}</code></pre><p>A persistent dictionary with weighted pairs. As such, a <code>PWDict</code> supports the typical operations of a <code>PDict</code> as well as the following:</p><ul><li>The <code>first</code> function yields the key-value pair with the highest weight.</li><li>The <code>pop</code> function yields a copy of the dictionary without the pair that has the highest weight.</li><li>Iteration occurs in the order of greatest to least weight.</li><li>The weights can be changed with the <code>getweight</code> and <code>setweight</code> functions; <code>setweight</code> yields a duplicate dictionary with updated weights.</li></ul><p>See also: <a href="#Air.PDict"><code>PDict</code></a>, <a href="#Air.getweight-Union{Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T, W, F, D}, S}} where {T, W, F, D, S}"><code>getweight</code></a>, <a href="#Air.setweight-Union{Tuple{X}, Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T, W, F, D}, S, X}} where {T, W, F, D, S, X&lt;:Number}"><code>setweight</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; PWDict{Symbol,Int}(:a =&gt; (1,0.1), :b =&gt; (2, 0.2), :c =&gt; (3, 0.3))
PWDict{Symbol,Int64,Float64} with 3 entries:
  :c =&gt; 3
  :b =&gt; 2
  :a =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/pwdict.jl#LL183-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PWIdDict" href="#Air.PWIdDict"><code>Air.PWIdDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PWIdDict{K,V}</code></pre><p>A persistent dictionary with weighted pairs. As such, a <code>PWIdDict</code> supports the typical operations of a <code>PIdDict</code> as well as the following:</p><ul><li>The <code>first</code> function yields the key-value pair with the highest weight.</li><li>The <code>pop</code> function yields a copy of the dictionary without the pair that has the highest weight.</li><li>Iteration occurs in the order of greatest to least weight.</li><li>The weights can be changed with the <code>getweight</code> and <code>setweight</code> functions; <code>setweight</code> yields a duplicate dictionary with updated weights.</li></ul><p>See also: <a href="#Air.PIdDict"><code>PIdDict</code></a>, <a href="#Air.PWDict"><code>PWDict</code></a>, <a href="#Air.getweight-Union{Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T, W, F, D}, S}} where {T, W, F, D, S}"><code>getweight</code></a>, <a href="#Air.setweight-Union{Tuple{X}, Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T, W, F, D}, S, X}} where {T, W, F, D, S, X&lt;:Number}"><code>setweight</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; PWIdDict{Symbol,Int}(:a =&gt; (1,0.1), :b =&gt; (2, 0.2), :c =&gt; (3, 0.3))
PWIdDict{Symbol,Int64,Float64} with 3 entries:
  :c =&gt; 3
  :b =&gt; 2
  :a =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/pwdict.jl#LL213-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PWIdSet" href="#Air.PWIdSet"><code>Air.PWIdSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PWIdSet{T}</code></pre><p>A persistent set with weighted elements. As such, a <code>PWIdSet</code> supports the typical operations of a <code>PIdSet</code> as well as the following:</p><ul><li>The <code>first</code> function yields the element with the highest weight.</li><li>The <code>pop</code> function yields a copy of the set without the element that has the highest weight.</li><li>Iteration occurs in the order of greatest to least weight.</li><li>The weights can be changed with the <code>getweight</code> and <code>setweight</code> functions; <code>setweight</code> yields a duplicate dictionary with updated weights.</li></ul><p>See also: <a href="#Air.PIdSet"><code>PIdSet</code></a>, <a href="#Air.PWSet"><code>PWSet</code></a>, <a href="#Air.getweight-Union{Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T, W, F, D}, S}} where {T, W, F, D, S}"><code>getweight</code></a>, <a href="#Air.setweight-Union{Tuple{X}, Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T, W, F, D}, S, X}} where {T, W, F, D, S, X&lt;:Number}"><code>setweight</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; PWIdSet{Symbol}(:a =&gt; 0.1, :b =&gt; 0.2, :c =&gt; 0.3)
PWIdSet{Symbol,Float64} with 3 elements:
  :c
  :b
  :a</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/pwset.jl#LL159-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.PWSet" href="#Air.PWSet"><code>Air.PWSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PWSet{K,V}</code></pre><p>A persistent set with weighted elements. As such, a <code>PWSet</code> supports the typical operations of a <code>PSet</code> as well as the following:</p><ul><li>The <code>first</code> function yields the element with the highest weight.</li><li>The <code>pop</code> function yields a copy of the set without the element that has the highest weight.</li><li>Iteration occurs in the order of greatest to least weight.</li><li>The weights can be changed with the <code>getweight</code> and <code>setweight</code> functions; <code>setweight</code> yields a duplicate dictionary with updated weights.</li></ul><p>See also: <a href="#Air.PSet"><code>PSet</code></a>, <a href="#Air.getweight-Union{Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T, W, F, D}, S}} where {T, W, F, D, S}"><code>getweight</code></a>, <a href="#Air.setweight-Union{Tuple{X}, Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T, W, F, D}, S, X}} where {T, W, F, D, S, X&lt;:Number}"><code>setweight</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; PWSet{Symbol}(:a =&gt; 0.1, :b =&gt; 0.2, :c =&gt; 0.3)
PWSet{Symbol,Float64} with 3 elements:
  :c
  :b
  :a</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/pwset.jl#LL129-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.Promise" href="#Air.Promise"><code>Air.Promise</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Promise{T}</code></pre><p>Promise objects represent placeholders for values that may or may not have been delivered yet. This is effectively a <code>Channel</code> object that can only be <code>put!</code> to a single time and all <code>take</code> calls on the promise will return that value. Promise values can be accessed via the <code>take()</code> function (not the <code>take!()</code> function) or via <code>p[]</code> for promise <code>p</code>. In both cases, the running thread is suspended until a value is delivered.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; p = Promise{Symbol}()
Promise{Symbol}(&lt;...&gt;)

julia&gt; isready(p)
false

julia&gt; put!(p, :value)
:value

julia&gt; isready(p)
true

julia&gt; take(p)
:value

julia&gt; p[]
:value</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/util.jl#LL327-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ReentrantRef" href="#Air.ReentrantRef"><code>Air.ReentrantRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReentrantRef{T}</code></pre><p>A <code>ReentrantRef</code> is a type of ref object that is thread-safe. There are a few strategies for this, each of which are encoded in a different object type that inheits from <code>ReentrantRef</code>. These types are as follows.</p><p><code>Var</code>: <code>Var</code> objects act like <code>Ref</code> objects except that changes to them are exclusively task-local and must be performed in specific scoped expressions. However, the state of all <code>Var</code> objects for the current task can also be saved and restored at a later point.</p><p><code>Actor</code>: <code>Actor</code> objects obey the actor pattern; you can call <code>send(fn, actor, args...)</code> where <code>fn</code> is a function that is, in another thread at some point, called as <code>fn(actor[], args...)</code>. The new value of the actor after running <code>fn</code> is the return value of the call.</p><p><code>Volatile</code>: <code>Volatile</code> objects are <code>Ref</code>s that can be changed by any thread but that must be changed only within a synchronized transaction that ensures that all reads and writes of volatiles, as well as reads from and sends to actors, are atomic: either they all happen successfully, or none of them do.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/api.jl#LL48-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.Transaction" href="#Air.Transaction"><code>Air.Transaction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Transaction</code></pre><p>A transaction object keeps track of what is going on during a particular transaction. These are generally low-level objects that shouldn&#39;t be touched directly.</p><p>Transactions have the following propertiies:</p><ul><li><code>state</code> is either <code>:running</code>, <code>:validating</code>, or <code>:error</code>;</li><li><code>rvolatiles</code> is the set of all <code>Volatile</code> objects that have been read during the transaction;</li><li><code>wvolatiles</code> is the set of all <code>Volatile</code> objects that have been changed;</li><li><code>actors</code> is the set of all <code>Actor</code> objects to which messagees have been sent during the transaction; and</li><li><code>sources</code> is the set of all <code>Source</code> objects from which items have been popped.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL519-L535">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.TransactionalRef" href="#Air.TransactionalRef"><code>Air.TransactionalRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TransactionalRef{T}</code></pre><p>A <code>TransactionalRef</code> is a reentrant reference that additional participates in transactions. Transactional refs include <code>Actor</code>s and <code>Volatile</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/api.jl#LL72-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.TxIO" href="#Air.TxIO"><code>Air.TxIO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TxIO</code></pre><p>The <code>TxIO</code> type is a derivative of the <code>IO</code> class and is intended for handling output to streams across multiple threads in a thread-safe way. <code>TxIO</code> objects can be constructed from <code>IO</code> objects and can be printed/written to like normal <code>IO</code> objects. However, all output is performed in a separate asynchronous thread, and writes that occur during a transaction always occur only if the transaction succeeds.</p><p>See also: <a href="#Air.Actor"><code>Actor</code></a>, <a href="#Air.airout"><code>airout</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL1065-L1076">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.TxRetryException" href="#Air.TxRetryException"><code>Air.TxRetryException</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TxRetryException</code></pre><p>A <code>TxRetryException</code> is throws when a transaction needs to be retried but an error hasn&#39;t necessarily been generated otherwise. This can be thrown during a transaction to restart the transaction; though doing this can easily lead to infinite loops.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL509-L516">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.Var" href="#Air.Var"><code>Air.Var</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Var{T}</code></pre><p>A <code>Var</code> object represents a task-local piece of data with a default value. You can access a <code>Var</code> with the <code>getindex</code> function (<code>var[]</code>) and you can set it with the <code>setindex!</code> function (<code>var[] = newval</code>). However, the new assignment will always be task-local only. Because of this, <code>Var</code>s are safe to access and update in a multi-threaded program.</p><p>All fields of a <code>Var</code> should be considered strictly private.</p><p>See also: <a href="#Air.@var-Tuple{Expr}"><code>@var</code></a>, <a href="#Air.ReentrantRef"><code>ReentrantRef</code></a>, <a href="#Air.vars"><code>vars</code></a>, <a href="#Air.withvars"><code>withvars</code></a>, <a href="#Air.wrapsetvars"><code>wrapsetvars</code></a>, <a href="#Air.wrapwithvars"><code>wrapwithvars</code></a>,  <code>Threads.current_task</code>, <code>Threads.task_local_storage</code>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; v = Var{Symbol}(:start_sym)
Var{Symbol}(@JIm7aUS2sOl: :start_sym; init=:start_sym)

julia&gt; v[]
:start_sym

julia&gt; withvars(v =&gt; :new_sym) do; v[] end
:new_sym

julia&gt; withvars(v =&gt; :new_sym) do; fetch(Threads.@spawn v[]) end
:start_sym

julia&gt; v[]
:start_sym</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/vars.jl#LL19-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.VarsDict" href="#Air.VarsDict"><code>Air.VarsDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VarsDict</code></pre><p>The type of a dictionary of <code>Var</code> bindings, as returned by the function <code>vars()</code> and as is required by the function <code>setvars()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/vars.jl#LL71-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.Volatile" href="#Air.Volatile"><code>Air.Volatile</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Volatile{T}(value)
Volatile{T}(value, filter_fn)
Volatile{T}(value, filter_fn, finalize_fn)</code></pre><p><code>Volatile</code> objects are <code>Ref</code> objects that must be used in conjunction with transaction blocks (see <a href="#Air.@tx-Tuple{Any}"><code>@tx</code></a> and <a href="#Air.tx-Tuple{F} where F&lt;:Function"><code>tx</code></a>). The value of a <code>Volatile</code> can be accessed at any time, and there is no particular guarantee that a <code>Volatile</code>&#39;s value won&#39;t be changed by another thread outside of a transaction, thus reading them outside of a transaction can potentially create race conditions. Critically, <code>Volatile</code> objects can only be set inside of a transaction, and, within a transaction, a <code>Volatile</code>&#39;s value is guaranteed to be constant. In other words, <code>Volatile</code> objects are <code>Ref</code> objects that behave as if they are locked for the executing thread whenever that thread is inside a transaction block.</p><p>The arguments <code>filter_fn</code> and <code>finnalize_fn</code> are functions for making sure that the value of a volatile conforms to some standard. The two functions are similar but are intended for slightly different use cases:</p><ul><li><code>filter_fn</code> is called every time the value of a volatile is set. The value saved in the volatile is <code>filter_fn(value)</code> instead of <code>value</code> itself. Values are only filtered when the volatile is set directly (<code>vol[] = value</code>)–-the filter is not rerun when the <code>filter_fn</code> is changed (via <code>setfilter!</code>) nor when the <code>finalize_fn</code> returns a value.</li><li><code>finalize_fn</code> is called with the volatile&#39;s value immediately after the body of the transaction has completed, but before a commit is attempted. The <code>finalize_fn</code> function acts like the <code>filter_fn</code> in that <code>finalize_fn(value)</code> replaces <code>value</code> in the volatile.</li></ul><p>Both <code>filter_fn</code> and <code>finalize_fn</code> can throw exceptions, which will abort the running transaction.</p><p>For a <code>Volatile</code> <code>v</code>, one may set <code>v</code>&#39;s stored value via <code>v[] = value</code>. This must be done inside a transaction (via <code>tx</code> or <code>@tx</code>). To change the filter or the finalize functions, use the <code>setfilter!</code> and <code>setfinalize!</code> functions, both of which also must be run in transactions as well.</p><p>See also: <a href="#Air.tx-Tuple{F} where F&lt;:Function"><code>tx</code></a>, <a href="#Air.@tx-Tuple{Any}"><code>@tx</code></a>, <a href="#Air.setfilter!-Union{Tuple{T}, Tuple{Volatile{T}, Function}} where T"><code>setfilter!</code></a>, <a href="#Air.setfinalize!-Union{Tuple{T}, Tuple{Volatile{T}, Function}} where T"><code>setfinalize!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; v = Volatile{Symbol}(:startval)
Volatile{Symbol}(@JIm7aUS2sOl: :startval)

julia&gt; @tx v[] = :newval
:newval

julia&gt; v[]
:newval</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL379-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.actor_main-Union{Tuple{Actor{T}}, Tuple{T}} where T" href="#Air.actor_main-Union{Tuple{Actor{T}}, Tuple{T}} where T"><code>Air.actor_main</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">actor_main(actor)</code></pre><p>The actor main function is what actually manages everything behind the scenes in the actor tasks. Note that this function and the task/thread it is running in is the only place that the actor&#39;s value can be legally changed. Changing the value anywhere else can result in undefined behavior. The actor&#39;s condition should never change.</p><p>This function is designed to process all the messages in an actor&#39;s queue then to return. When a new thread wants to enqueue a message to an actor that has an empty queue, that thread must spin up the <code>actor_main</code> function to process the items in the queue (this is done by the <code>send</code> function automatically).</p><p>This function is part of <code>Air</code>&#39;s internal/private implementation details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL165-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.actor_reset!-Union{Tuple{T}, Tuple{Actor{T}, Any}} where T" href="#Air.actor_reset!-Union{Tuple{T}, Tuple{Actor{T}, Any}} where T"><code>Air.actor_reset!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">actor_reset!(actor, val)</code></pre><p>Resets the given actor to have the given value. If the actor is not in an error state, yields <code>nothing</code> and does nothing. Otherwise, yields the <code>ActorExcption</code> object that was cleared. It is required that the actor&#39;s mutex be held at ths time this function is called.</p><p>This function is considered part of <code>Air</code>&#39;s internal/private implementation details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL316-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.actor_reset-Union{Tuple{S}, Tuple{T}, Tuple{Actor{T}, S}} where {T, S}" href="#Air.actor_reset-Union{Tuple{S}, Tuple{T}, Tuple{Actor{T}, S}} where {T, S}"><code>Air.actor_reset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">actor_reset(a, s)</code></pre><p>If the given <code>Actor</code> object <code>a</code> is in an error state, this function resets the actor to have the new value <code>s</code> then yields the <code>ActorException</code> object that was just cleared. If <code>a</code> is not in an error state, this function simply yields <code>nothing</code>.</p><p>This function is considered part of the internal/private interface of <code>Air</code> and shouldn&#39;t generally be called outside of it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL911-L921">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.actor_send!-Union{Tuple{T}, Tuple{Actor{T}, Air.ActorMsg}} where T" href="#Air.actor_send!-Union{Tuple{T}, Tuple{Actor{T}, Air.ActorMsg}} where T"><code>Air.actor_send!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">actor_send!(actor, message)</code></pre><p>Enqueues the given message to the given actor and starts the actor&#39;s task, if necessary. This function requires that the actor&#39;s condition be held. Yields the actor.</p><p>This function is considered part of <code>Air</code>&#39;s internal/private implementation details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL288-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.actor_send-Union{Tuple{T}, Tuple{Actor{T}, Air.ActorMsg}} where T" href="#Air.actor_send-Union{Tuple{T}, Tuple{Actor{T}, Air.ActorMsg}} where T"><code>Air.actor_send</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">actor_send(a, msg)</code></pre><p>Adds the given <code>ActorMsg</code> message object <code>msg</code> to the queue of the given <code>Actor</code> object <code>a</code> such that it will be processed in a separate thread. Yields <code>nothing</code>.</p><p>This function is considered part of the internal/private interface of <code>Air</code> and shouldn&#39;t generally be called outside of it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL957-L966">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.actor_start!-Union{Tuple{Actor{T}}, Tuple{T}} where T" href="#Air.actor_start!-Union{Tuple{Actor{T}}, Tuple{T}} where T"><code>Air.actor_start!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">actor_start!(actor)</code></pre><p>If the given <code>Actor</code> object is not in an error state, is not running, and does not have an empty queue, then <code>actor_start!(actor)</code> will start <code>actor</code>&#39;s processing task. This should only be called by <code>send!</code> when the first message to an empty queue is finalized.</p><p>If either the actor is already running or the task is successfully started, then that task is yielded. If the actor has an empty queue, then nothing is returned, and if the actor is in an error state, then an exception is thrown.</p><p>Note: It is required that the mutx for the given actor be held when this function is called; otherwise race conditions could be inadvertantely created. The <a href="#Air.actor_start-Union{Tuple{Actor{T}}, Tuple{T}} where T"><code>actor_start</code></a> method locks the actor&#39;s mutex then calls this function. Both methods are private to <code>Air</code> and should not generally be used outside of it.</p><p>This function is considered part of <code>Air</code>&#39;s internal/private implementation details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL232-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.actor_start-Union{Tuple{Actor{T}}, Tuple{T}} where T" href="#Air.actor_start-Union{Tuple{Actor{T}}, Tuple{T}} where T"><code>Air.actor_start</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">actor_start(actor)</code></pre><p>If the given <code>Actor</code> object is not in an error state, is not running, and does not have an empty queue, <code>actor_start(actor)</code> will start <code>actor</code>&#39;s processing task. This should only be called by <code>send!</code> when the first message to an empty queue is finalized.</p><p>If either the actor is already running or the task is successfully started, then that task is yielded. If the actor has an empty queue, then nothing is returned, and if the actor is in an error state, then an exception is thrown.</p><p>This function is considered part of <code>Air</code>&#39;s internal/private implementation details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL264-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.actor_value-Union{Tuple{Actor{T}}, Tuple{T}} where T" href="#Air.actor_value-Union{Tuple{Actor{T}}, Tuple{T}} where T"><code>Air.actor_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">actor_value(a)</code></pre><p>Yields the in-transaction value for the given <code>Actor</code> object <code>a</code> if there is a running transaction; otherwise yields the current out-of-transaction value of <code>a</code>.</p><p>This function is considered part of the internal/private interface of <code>Air</code> and shouldn&#39;t generally be called outside of it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL892-L901">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.currtx-Tuple{}" href="#Air.currtx-Tuple{}"><code>Air.currtx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">currtx()</code></pre><p>Yields the current <code>Transaction</code> object, or <code>nothing</code> if there is no transaction running in the current task.</p><p>See also: <a href="#Air.Transaction"><code>Transaction</code></a></p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; currtx() === nothing
true

julia&gt; @tx (currtx() === nothing)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL581-L604">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.delete-Union{Tuple{J}, Tuple{V}, Tuple{K}, Tuple{AbstractDict{K, V}, J}} where {K, V, J}" href="#Air.delete-Union{Tuple{J}, Tuple{V}, Tuple{K}, Tuple{AbstractDict{K, V}, J}} where {K, V, J}"><code>Air.delete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">delete(coll, k)</code></pre><p>Yields a copy of the collection <code>coll</code> with the item associated with the given index or key <code>k</code> deleted. This function works on dictionaries, vectors, tuples, and sets, and it always yields a copy of the collection without modifying its aguments. For the persistent collections defined in Air, this is efficient, but for most mutable objects, this is <code>O(n)</code>.</p><p>See also: <code>Base.delete!</code>, <a href="#Air.insert"><code>insert</code></a>, <a href="#Air.pop"><code>pop</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; delete((:a,:b,:c,:d), 2)
(:a, :c, :d)</code></pre><pre><code class="language-julia-repl">julia&gt; u = [:a,:b,:c,:d]; delete(u, 1)
3-element Array{Symbol,1}:
 :b
 :c
 :d</code></pre><pre><code class="language-julia-repl">julia&gt; s1 = Set([:a,:b,:c,:d]); s2 = delete(s1, :d); (:d in s1, :d in s2)
(true, false)</code></pre><pre><code class="language-julia-repl">julia&gt; b = BitArray([0,0,0,1,0]); delete(b, 4)
4-element BitArray{1}:
 0
 0
 0
 0

julia&gt; b[2]
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/api.jl#LL681-L729">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.depth_to_bitshift-Tuple{Integer}" href="#Air.depth_to_bitshift-Tuple{Integer}"><code>Air.depth_to_bitshift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">depth_to_bitshift(depth)</code></pre><p>Yields the tuple (B0,S) of the first bit index and the shift for the given depth.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/ptree.jl#LL104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.equalfn-Tuple{T} where T" href="#Air.equalfn-Tuple{T} where T"><code>Air.equalfn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">equalfn(x)</code></pre><p>If <code>x</code> is an object (such as a <code>PSet</code> or <code>Dict</code>) that has an opinion about equality, <code>equalfn(x)</code> returns the function that it uses.</p><p>See also: <a href="#Air.hashfn-Tuple{T} where T"><code>hashfn</code></a></p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; equalfn(Dict) == isequal
true

julia&gt; equalfn(IdDict) == (===)
true

julia&gt; equalfn(PSet) == isequal
true

julia&gt; equalfn(PArray)
ERROR: ArgumentError: no equalfn for type PArray</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/api.jl#LL83-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.geterror-Union{Tuple{Actor{T}}, Tuple{T}} where T" href="#Air.geterror-Union{Tuple{Actor{T}}, Tuple{T}} where T"><code>Air.geterror</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">geterror(actor)</code></pre><p>If the given <code>Actor</code> object is currently in an error state, then yields the <code>ActorException</code> object that describes the error. Otherwise, yields <code>nothing</code>.</p><p>See also: <a href="#Air.Actor"><code>Actor</code></a>, <a href="#Air.reset-Union{Tuple{S}, Tuple{T}, Tuple{Actor{T}, S}} where {T, S}"><code>reset</code></a>, <a href="#Air.send-Union{Tuple{T}, Tuple{Function, Actor{T}}} where T"><code>send</code></a></p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; a = Actor{Symbol}(:start_sym)
Actor{Symbol}(@JIm7aUS2sOl: :start_sym)

julia&gt; geterror(a) === nothing
true

julia&gt; send(a) do val; error(&quot;test&quot;) end
Actor{Symbol}(@JIm7aUS2sOl: :start_sym)

julia&gt; sleep(1); a
Actor{Symbol}(@JIm7aUS2sOl: --error--)

julia&gt; geterror(a) isa ActorException
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL1026-L1058">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.getfilter-Union{Tuple{Volatile{T}}, Tuple{T}} where T" href="#Air.getfilter-Union{Tuple{Volatile{T}}, Tuple{T}} where T"><code>Air.getfilter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getfilter(v)</code></pre><p>Yields the filter-function for the volatile v.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL820-L824">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.getfinalize-Union{Tuple{Volatile{T}}, Tuple{T}} where T" href="#Air.getfinalize-Union{Tuple{Volatile{T}}, Tuple{T}} where T"><code>Air.getfinalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getfinalize(v)</code></pre><p>Yields the finalize-function for the volatile v.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL828-L832">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.getpair" href="#Air.getpair"><code>Air.getpair</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getpair(d, k)</code></pre><p>If the key <code>k</code> is found in the dictionary <code>d</code>, yields the pair (<code>k =&gt; d[k]</code>); otherwise yields <code>missing</code>.</p><p>See also: <code>Base.get</code>, <code>Base.getindex</code>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; d = Dict(:a =&gt; 1, :b =&gt; 2, :c =&gt; 3); getpair(d, :a)
:a =&gt; 1

julia&gt; getpair(d, :x)
missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/api.jl#LL831-L854">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.getweight-Union{Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T, W, F, D}, S}} where {T, W, F, D, S}" href="#Air.getweight-Union{Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T, W, F, D}, S}} where {T, W, F, D, S}"><code>Air.getweight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getweight(h, x)</code></pre><p>Yields the weight for the given value x in the given persistent heap or persistent weighted collection h. If h is a weighted dictionary, then x should be the key.</p><p>If the key or object x is not found in the collection h, then 0 is returned.</p><p>See also: <a href="#Air.setweight-Union{Tuple{X}, Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T, W, F, D}, S, X}} where {T, W, F, D, S, X&lt;:Number}"><code>setweight</code></a>, <a href="#Air.PWDict"><code>PWDict</code></a>, <a href="#Air.PWSet"><code>PWSet</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; d = PWSet{Symbol}(:a =&gt; 1.0, :b =&gt; 2.0, :c =&gt; 3.0)
PWSet{Symbol,Float64} with 3 elements:
  :c
  :b
  :a

julia&gt; getweight(d, :a)
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/pheap.jl#LL229-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.hashfn-Tuple{T} where T" href="#Air.hashfn-Tuple{T} where T"><code>Air.hashfn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hashfn(x)</code></pre><p>If <code>x</code> is an object (such as a <code>PSet</code> or <code>Dict</code>) that has an opinion about how it hashes objects, <code>hashfn(x)</code> returns the function that it uses. It is sufficient in almost all circumstances to define <code>equalfn(T)</code>; the <code>hashfn</code> should always match the <code>equalfn</code> regardless.</p><p>See also: <a href="#Air.equalfn-Tuple{T} where T"><code>equalfn</code></a></p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; hashfn(Dict) == hash
true

julia&gt; hashfn(IdDict) == objectid
true

julia&gt; hashfn(PSet) == hash
true

julia&gt; hashfn(PArray)
ERROR: ArgumentError: no equalfn for type PArray</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/api.jl#LL123-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.highmask-Union{Tuple{K}, Tuple{T}, Tuple{K, Type{T}}} where {T&lt;:Unsigned, K&lt;:Integer}" href="#Air.highmask-Union{Tuple{K}, Tuple{T}, Tuple{K, Type{T}}} where {T&lt;:Unsigned, K&lt;:Integer}"><code>Air.highmask</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">highmask(bitno, T)
highmask(bitno)</code></pre><p>Yields a mask of (unsigned integer) type T with all bits above the given bit number set to true and all bits below that number set to false. The bit itself is set to true. Bits are indexed starting at 0.</p><p>The default value of T is the PTree hash type (HASH_T).</p><p>highmask(bitno) is equal to ~lowmask(bitno).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/ptree.jl#LL76-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.insert" href="#Air.insert"><code>Air.insert</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insert(coll, idx, val)</code></pre><p>Yields a copy of the given collection <code>coll</code> with the given value <code>cal</code> inserted at the given index. Roughly equivalent to <code>insert!(copy(arr), idx, va)</code>: the <code>insert</code> function never modifies its arguments and always yields a copy. For the persistent collections defined in Air, this operation is efficient, but for most mutable objects, this is <code>O(n)</code>.</p><p>See also: <code>Base.insert!</code>, <a href="#Air.push"><code>push</code></a>, <a href="#Air.delete-Union{Tuple{J}, Tuple{V}, Tuple{K}, Tuple{AbstractDict{K, V}, J}} where {K, V, J}"><code>delete</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; insert((:a,:b,:c,:d), 2, :x)
(:a, :x, :b, :c, :d)</code></pre><pre><code class="language-julia-repl">julia&gt; u = [:a,:b,:c,:d]; insert(u, 1, :x)
5-element Array{Symbol,1}:
 :x
 :a
 :b
 :c
 :d

julia&gt; length(u)
4</code></pre><pre><code class="language-julia-repl">julia&gt; b = BitArray([0,0,0,0]); insert(b, 2, 1)
5-element BitArray{1}:
 0
 1
 0
 0
 0

julia&gt; b[2]
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/api.jl#LL522-L571">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.lockall" href="#Air.lockall"><code>Air.lockall</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lockall(f, l1, l2, ...)</code></pre><p>Locks all of the lockable objects <code>l1</code>, <code>l2</code>, etc. then runs <code>f</code>, unlocks the objects, and returns the return value of <code>f()</code>.</p><p>See also: <code>Threads.ReentrantLock</code></p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; (r1, r2, r3) = [ReentrantLock() for _ in 1:3]
       lockall(r1, r2, r3) do; :success end
:success

julia&gt; lockall([r1, r2, r3]) do; :success end
:success

julia&gt; lockall((r1, r2, r3)) do; :success end
:success</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/util.jl#LL478-L505">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.lowmask-Union{Tuple{K}, Tuple{T}, Tuple{K, Type{T}}} where {T&lt;:Unsigned, K&lt;:Integer}" href="#Air.lowmask-Union{Tuple{K}, Tuple{T}, Tuple{K, Type{T}}} where {T&lt;:Unsigned, K&lt;:Integer}"><code>Air.lowmask</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lowmask(bitno, T)
lowmask(bitno)</code></pre><p>Yields a mask of (unsigned integer) type T with all bits above the given bit number set to false and all bits below that number set to true. The bit itself is set to false. Bits are indexed starting at 0.</p><p>The default value of T is the PTree hash type (HASH_T).</p><p>lowmask(bitno) is equal to ~highmask(bitno).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/ptree.jl#LL61-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.pfill-Union{Tuple{T}, Tuple{T, Vararg{Integer, N} where N}} where T" href="#Air.pfill-Union{Tuple{T}, Tuple{T, Vararg{Integer, N} where N}} where T"><code>Air.pfill</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pfill(val, dims...)</code></pre><p>Yields a persistent array (<code>PArray</code>) of values exactly as done by the <code>fill()</code> function.</p><p>See also <a href="#Air.pones-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any, N} where N}} where T"><code>pones</code></a>, <a href="#Air.pzeros-Union{Tuple{T}, Tuple{Type{T}, Vararg{Integer, N} where N}} where T"><code>pzeros</code></a>, <code>fill</code></p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air, SparseArrays
end</code></pre><pre><code class="language-julia-repl">julia&gt; pfill(NaN, 3)
3-element PArray{Float64,1}:
 NaN
 NaN
 NaN</code></pre><pre><code class="language-julia-repl">julia&gt; pfill(:abc, 2, 3)
2×3 PArray{Symbol,2}:
 :abc  :abc  :abc
 :abc  :abc  :abc</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/parray.jl#LL633-L663">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.pones-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any, N} where N}} where T" href="#Air.pones-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any, N} where N}} where T"><code>Air.pones</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pones(dims...)
pones(T, dims...)</code></pre><p>Yields a persistent array (<code>PArray</code>) of ones exactly as done by the <code>ones()</code> function.</p><p>See also <a href="#Air.pzeros-Union{Tuple{T}, Tuple{Type{T}, Vararg{Integer, N} where N}} where T"><code>pzeros</code></a>, <a href="#Air.pfill-Union{Tuple{T}, Tuple{T, Vararg{Integer, N} where N}} where T"><code>pfill</code></a>, <code>ones</code></p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air, SparseArrays
end</code></pre><pre><code class="language-julia-repl">julia&gt; pones(Integer, 3)
3-element PArray{Integer,1}:
 1
 1
 1</code></pre><pre><code class="language-julia-repl">julia&gt; pones(Bool, (1,2))
1×2 PArray{Bool,2}:
 1  1</code></pre><pre><code class="language-julia-repl">julia&gt; pones(2, 3)
2×3 PArray{Float64,2}:
 1.0  1.0  1.0
 1.0  1.0  1.0</code></pre><pre><code class="language-julia-repl">julia&gt; pones((1, 1, 1, 1))
1×1×1×1 PArray{Float64,4}:
[:, :, 1, 1] =
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/parray.jl#LL583-L627">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.pop" href="#Air.pop"><code>Air.pop</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pop(coll)</code></pre><p>Yields a tuple <code>(last, most)</code> where <code>last</code> is the last element of the given collection and most is a duplicate tuple of all but the last element of tup. This is basically a persistent equivalent to the <code>pop!</code> function that never modifies the given <code>coll</code>. For persistent collections in Air, these operations are efficient, but for most mutable types, it is <code>O(n)</code>.</p><pre><code class="language-none">pop(coll, key[, default])</code></pre><p>Similar to <code>pop!</code>, pops the specific <code>key</code> from the given collection <code>coll</code> and yields <code>(val, rest)</code> where <code>val</code> is the value associated with <code>key</code> in <code>coll</code> and <code>rest</code> is the remainder of the collection without <code>key</code>. If the <code>key</code> is not in <code>coll</code>, then <code>default</code> is yielded or an error is thrown.</p><p>See also: <code>Base.pop!</code>, <a href="#Air.push"><code>push</code></a>, <a href="#Air.popat"><code>popat</code></a>, <a href="#Air.delete-Union{Tuple{J}, Tuple{V}, Tuple{K}, Tuple{AbstractDict{K, V}, J}} where {K, V, J}"><code>delete</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; pop((:a,:b,:c,:d))
(:d, (:a, :b, :c))

julia&gt; u = [:a,:b,:c,:d]; pop(u)
(:d, [:a, :b, :c])

julia&gt; length(u)
4

julia&gt; s = Set([:a, :b, :c]); pop(s, :c)
(:c, Set([:a, :b]))

julia&gt; :c in s
true</code></pre><pre><code class="language-julia-repl">julia&gt; d = Dict(:a =&gt; 1, :b =&gt; 2, :c =&gt; 3); pop(d, :c)
(3, Dict(:a =&gt; 1,:b =&gt; 2))

julia&gt; d[:c]
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/api.jl#LL289-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.popat" href="#Air.popat"><code>Air.popat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">popat(coll, k)</code></pre><p>Yields a tuple <code>(el, rest)</code> where <code>el</code> is the <code>k</code>th element of the given collection <code>coll</code> and <code>rest</code> is a duplicate of all but the <code>k</code>th element of <code>coll</code>. This is basically a persistent equivalent to the <code>popat!</code> function that never modifies the given <code>coll</code>. For persistent collections in Air, these operations are efficient, but for most mutable types, it is <code>O(n)</code>.</p><p>See also: <code>Base.popat!</code>, <a href="#Air.pop"><code>pop</code></a>, <a href="#Air.popfirst"><code>popfirst</code></a>, <a href="#Air.delete-Union{Tuple{J}, Tuple{V}, Tuple{K}, Tuple{AbstractDict{K, V}, J}} where {K, V, J}"><code>delete</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; popat((:a,:b,:c,:d), 2)
(:b, (:a, :c, :d))

julia&gt; u = [:a,:b,:c,:d]; popat(u, 3)
(:c, [:a, :b, :d])

julia&gt; length(u)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/api.jl#LL479-L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.popfirst" href="#Air.popfirst"><code>Air.popfirst</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">popfirst(coll)</code></pre><p>Yields a tuple <code>(first, rest)</code> where <code>first</code> is the first element of the given collection and rest is a duplicate tuple of all but the first element of <code>tup</code>. This is basically a persistent equivalent to the <code>popfirst!</code> function that never modifies the given <code>coll</code>. For persistent collections in Air, these operations are efficient, but for most mutable types, it is <code>O(n)</code>.</p><p>See also: <code>Base.popfirst!</code>, <a href="#Air.pushfirst"><code>pushfirst</code></a>, <a href="#Air.popat"><code>popat</code></a>, <a href="#Air.delete-Union{Tuple{J}, Tuple{V}, Tuple{K}, Tuple{AbstractDict{K, V}, J}} where {K, V, J}"><code>delete</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; popfirst((:a,:b,:c,:d))
(:a, (:b, :c, :d))

julia&gt; u = [:a,:b,:c,:d]; popfirst(u)
(:a, [:b, :c, :d])

julia&gt; length(u)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/api.jl#LL441-L471">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_bitshift-Tuple{UInt64}" href="#Air.ptree_bitshift-Tuple{UInt64}"><code>Air.ptree_bitshift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_bitshift(nodeid)</code></pre><p>Yields the bitshift for the given ptree node id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/ptree.jl#LL121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_cellindex!-Tuple{UInt64, UInt64, UInt64}" href="#Air.ptree_cellindex!-Tuple{UInt64, UInt64, UInt64}"><code>Air.ptree_cellindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_cellindex!(ptree, leafid)
ptree_cellindex!(nodeid, bits, leafid)</code></pre><p>Yields the index into the ptree&#39;s cell vector of the child containing the leaf with the given id. If the ptree does not contain the given leafid because the appropriate bit is not set then 0 is returned. However, unlike the function ptree_cellindex(), this function does not check whether or not the given leafid is in the set of possible children of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/ptree.jl#LL294-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_cellindex-Tuple{UInt64, UInt64, UInt64}" href="#Air.ptree_cellindex-Tuple{UInt64, UInt64, UInt64}"><code>Air.ptree_cellindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_cellindex(ptree, leafid)
ptree_cellindex(nodeid, bits, leafid)</code></pre><p>Yields a tuple (present, bitindex, cellindex) in which [1] present is a boolean indicating whether a ptree containing the given leafid or the leaf itself is a child of the given ptree; [2] bitindex is the index into ptree&#39;s bits integer  for the given leaf, and cellindex is the inndex innto the ptree&#39;s cell array  where that child is or would be found. If the leafid is outside of the given ptree (i.e., it cannot exist beneath this ptree) then the cellindex returned returned is 0, but the bitindex will still match the appropriate shift for the ptree&#39;s depth.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/ptree.jl#LL269-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_cellkey-Tuple{UInt64, UInt64}" href="#Air.ptree_cellkey-Tuple{UInt64, UInt64}"><code>Air.ptree_cellkey</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_cellkey(ptree, childidx)</code></pre><p>Yields the leafid (a HASH_T value) of the key that goes with the particular child index that is given. This only works correctly for twig nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/ptree.jl#LL315-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_depth-Tuple{UInt64}" href="#Air.ptree_depth-Tuple{UInt64}"><code>Air.ptree_depth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_depth(nodeaddr)</code></pre><p>Yields the depth of the node with the given node address. This depth is in the theoretical complete tree, not in the reified tree represented with memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/ptree.jl#LL97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_firstbit-Tuple{UInt64}" href="#Air.ptree_firstbit-Tuple{UInt64}"><code>Air.ptree_firstbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_firstbit(nodeid)</code></pre><p>Yields the first-bit for the given ptree node id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/ptree.jl#LL133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_highbitdiff-Tuple{UInt64, UInt64}" href="#Air.ptree_highbitdiff-Tuple{UInt64, UInt64}"><code>Air.ptree_highbitdiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_highbitdiff(id1, id2)</code></pre><p>Yields the highest bit that is different between id1 and id2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/ptree.jl#LL195-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_id-Tuple{Integer, Integer}" href="#Air.ptree_id-Tuple{Integer, Integer}"><code>Air.ptree_id</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_id(minleaf, depth)</code></pre><p>Yields the node-id for the node whose minimum leaf and depth are given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/ptree.jl#LL166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_isbeneath-Tuple{UInt64, UInt64}" href="#Air.ptree_isbeneath-Tuple{UInt64, UInt64}"><code>Air.ptree_isbeneath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_isbeneath(nodeid, leafid)</code></pre><p>Yields true if the given leafid can be found beneath the given node-id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/ptree.jl#LL186-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_maxleaf-Tuple{UInt64}" href="#Air.ptree_maxleaf-Tuple{UInt64}"><code>Air.ptree_maxleaf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_maxleaf(nodeid)</code></pre><p>Yields the maximum child leaf index assiciated with the given nodeid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/ptree.jl#LL145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_minleaf-Tuple{UInt64}" href="#Air.ptree_minleaf-Tuple{UInt64}"><code>Air.ptree_minleaf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_minleaf(nodeid)</code></pre><p>Yields the minimum child leaf index associated with the given nodeid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/ptree.jl#LL139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_minmaxleaf-Tuple{UInt64}" href="#Air.ptree_minmaxleaf-Tuple{UInt64}"><code>Air.ptree_minmaxleaf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_minmaxleaf(nodeid)</code></pre><p>Yields the (min, max) child leaf index assiciated with the given nodeid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/ptree.jl#LL155-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_parentid-Tuple{UInt64}" href="#Air.ptree_parentid-Tuple{UInt64}"><code>Air.ptree_parentid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_parentid(nodeid0)</code></pre><p>Yields the node-id of the parent of the given node. Note that node 0 (the tree&#39;s theoretical root) has no parent. If given a node id of 0, this function will return an arbitrary large number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/ptree.jl#LL174-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.ptree_shift-Tuple{UInt64}" href="#Air.ptree_shift-Tuple{UInt64}"><code>Air.ptree_shift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ptree_shift(nodeid)</code></pre><p>Yields the shift for the given ptree node id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/ptree.jl#LL127-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.push" href="#Air.push"><code>Air.push</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">push(coll, val)
push(coll1, val1, val2...)</code></pre><p>Yields a copy of the given collection <code>coll</code> with the given value <code>val</code> appended. This function is essentially a persistent equivalent of the <code>push!</code> function that never modifies the object <code>coll</code>. For persistent collections in  the Air library, this operation is efficient, but for most mutable objects, it is <code>O(n)</code>.</p><p>See also: <code>Base.push!</code>, <a href="#Air.pop"><code>pop</code></a>, <code>Base.setindex!</code>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; push((:a,:b,:c,:d), :e)
(:a, :b, :c, :d, :e)</code></pre><pre><code class="language-julia-repl">julia&gt; u = [:a,:b,:c,:d]; push(u, :e)
5-element Array{Symbol,1}:
 :a
 :b
 :c
 :d
 :e</code></pre><pre><code class="language-julia-repl">julia&gt; s = Set([:a, :b, :c]); push(s, :d)
Set{Symbol} with 4 elements:
  :a
  :b
  :d
  :c</code></pre><pre><code class="language-julia-repl">julia&gt; d = Dict(:a =&gt; 1, :b =&gt; 2); push(d, :c =&gt; 3, :d =&gt; 4)
Dict{Symbol,Int64} with 4 entries:
  :a =&gt; 1
  :b =&gt; 2
  :d =&gt; 4
  :c =&gt; 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/api.jl#LL223-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.pushfirst" href="#Air.pushfirst"><code>Air.pushfirst</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pushfirst(coll, val)
pushfirst(coll1, val1, val2...)</code></pre><p>Yields a copy of the given collection <code>coll</code> with the given value <code>val</code> prepended. This function is essentially a persistent equivalent of the <code>pushfirst!</code> function that never modifies the object <code>coll</code>. For persistent collections in the Air library, this operation is efficient, but for most mutable objects, it is <code>O(n)</code>.</p><p>See also: <code>Base.pushfirst!</code>, <a href="#Air.popfirst"><code>popfirst</code></a>, <code>Base.setindex!</code>, <a href="#Air.push"><code>push</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; pushfirst((:a,:b,:c,:d), :e)
(:e, :a, :b, :c, :d)

julia&gt; u = [:a,:b,:c,:d]; pushfirst(u, :e)
5-element Array{Symbol,1}:
 :e
 :a
 :b
 :c
 :d

julia&gt; length(u)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/api.jl#LL395-L431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.pzeros-Union{Tuple{T}, Tuple{Type{T}, Vararg{Integer, N} where N}} where T" href="#Air.pzeros-Union{Tuple{T}, Tuple{Type{T}, Vararg{Integer, N} where N}} where T"><code>Air.pzeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pzeros(dims...)
pzeros(T, dims...)</code></pre><p>Yields a persistent array (<code>PArray</code>) of zeros exactly as done by the <code>zeros()</code> function.</p><p>See also <a href="#Air.pones-Union{Tuple{T}, Tuple{Type{T}, Vararg{Any, N} where N}} where T"><code>pones</code></a>, <a href="#Air.pfill-Union{Tuple{T}, Tuple{T, Vararg{Integer, N} where N}} where T"><code>pfill</code></a>, <code>zeros</code></p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air, SparseArrays
end</code></pre><pre><code class="language-julia-repl">julia&gt; pzeros(Integer, 3)
3-element PArray{Integer,1}:
 0
 0
 0</code></pre><pre><code class="language-julia-repl">julia&gt; pzeros(Bool, (1,2))
1×2 PArray{Bool,2}:
 0  0</code></pre><pre><code class="language-julia-repl">julia&gt; pzeros(2, 3)
2×3 PArray{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0</code></pre><pre><code class="language-julia-repl">julia&gt; pzeros((1, 1, 1, 1))
1×1×1×1 PArray{Float64,4}:
[:, :, 1, 1] =
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/parray.jl#LL533-L577">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.reset-Union{Tuple{S}, Tuple{T}, Tuple{Actor{T}, S}} where {T, S}" href="#Air.reset-Union{Tuple{S}, Tuple{T}, Tuple{Actor{T}, S}} where {T, S}"><code>Air.reset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reset(actor, x)</code></pre><p>If the given actor is in an error state, this (1) resets it, meaning it will start handling sent messages again, (2) gives it the new initial value <code>x</code>, and (3) yields the <code>ActorException</code> object that was just clared.  If the actor is not in an error state, this just yields <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL946-L953">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.send-Union{Tuple{T}, Tuple{Function, Actor{T}}} where T" href="#Air.send-Union{Tuple{T}, Tuple{Function, Actor{T}}} where T"><code>Air.send</code></a> — <span class="docstring-category">Method</span></header><section><div><p>send(fn, actor)</p><p>The <code>send()</code> method can be used to send a function to an actor. The function <code>fn</code> is put in the actor&#39;s queue, which is processed sequentially by a separate thread.  In the actual function call that is evaluated in this separate thread, the function is passed the stored value of the actor, and the return value of the function becomes the new stored value of the actor.</p><p>Note that the value of an actor when <code>send()</code> is called does not make any guarantee about its value when the function that is sent gets evaluated–-other functions may be processed in the interim.</p><p>If <code>send()</code> is called inside of a transaction, then the function is not immediately queued but rather is held until the transaction successfully completes. Once this happens, all sends are dispatched simultaneously such that two sends to the same actor during the same transaction will always run back-to-back in the actor&#39;s processing thread.</p><p><strong>Important</strong>. Due to the design pattern described in the previous paragraph, one should never wait on the result of a function sent to an actor during a transaction. This mistake might be made, for example, by sendng an actor, during a transactoin, a function that delivers some result to a <a href="#Air.Promise"><code>Promise</code></a> object. If the sending thread then waits on that promise while still in the same transaction then it will deadlock because the sent function is not put in the actor&#39;s queue until the enclosing transaction is finished.  Thus the promise will never recieve the result from the actor.</p><p>TL;DR–-When you touch an actor in a transaction, it&#39;s value freezes inside the transaction. So if the transaction somehow waits for the actor to update or to do something, that transaction will deadlock.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL991-L1022">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.setfilter!-Union{Tuple{T}, Tuple{Volatile{T}, Function}} where T" href="#Air.setfilter!-Union{Tuple{T}, Tuple{Volatile{T}, Function}} where T"><code>Air.setfilter!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setfilter!(vol, fn)</code></pre><p>Sets the filter-function associated with the Volatile object vol. Any time that the vol is set (<code>vol[] = x</code>) the filter-function is called and the value saved in <code>vol</code> is instead <code>fn(x)</code>. This must be called within a transaction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL835-L841">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.setfinalize!-Union{Tuple{T}, Tuple{Volatile{T}, Function}} where T" href="#Air.setfinalize!-Union{Tuple{T}, Tuple{Volatile{T}, Function}} where T"><code>Air.setfinalize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setfinalize!(vol, fn)</code></pre><p>Sets the finalize-function associated with the Volatile object vol. Any time that a transaction contains a change to <code>vol</code>, immediately prior to making an attempt at committing the transaction, the finalize function is called and the value committed to <code>vol</code> is instead <code>fn(x)</code> where <code>x</code> is the value set to <code>vol</code> in the transaction. This funvtion must also be called within a transaction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL848-L857">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.setvars" href="#Air.setvars"><code>Air.setvars</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setvars(f, vardict)</code></pre><p>Runs the function <code>f</code> in a context in which all <code>Var</code> objectss have been bound to the values given in the dictionary <code>vardict</code>. The keys of this dictionary must be <code>Var</code> objects. Once the function <code>f</code> has finished running, the <code>Var</code> objects are reverted to their calling-frame values. The current <code>vardict</code> object can be obtained by calling <code>vars()</code>.</p><p>See also: <a href="#Air.Var"><code>Var</code></a>, <a href="#Air.@var-Tuple{Expr}"><code>@var</code></a>, <a href="#Air.vars"><code>vars</code></a>, <a href="#Air.withvars"><code>withvars</code></a>, <a href="#Air.wrapwithvars"><code>wrapwithvars</code></a>, <a href="#Air.wrapsetvars"><code>wrapsetvars</code></a></p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; v = Var{Symbol}(:initval)
Var{Symbol}(@hxC65AWl: :initval; init=:initval)

julia&gt; v[]
:initval

julia&gt; setvars(IdDict(v =&gt; :newval)) do; v[] end
:newval</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/vars.jl#LL146-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.setweight-Union{Tuple{X}, Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T, W, F, D}, S, X}} where {T, W, F, D, S, X&lt;:Number}" href="#Air.setweight-Union{Tuple{X}, Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T, W, F, D}, S, X}} where {T, W, F, D, S, X&lt;:Number}"><code>Air.setweight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setweight(h, x, w)</code></pre><p>Sets the weight of the value x in the given persistent heap or persistent weighted collection object h to be w and yields the new updated version of h. If x is not already in the object h, then an error is thrown.</p><p>See also: <a href="#Air.getweight-Union{Tuple{S}, Tuple{D}, Tuple{F}, Tuple{W}, Tuple{T}, Tuple{Air.PHeap{T, W, F, D}, S}} where {T, W, F, D, S}"><code>getweight</code></a>, <a href="#Air.PWDict"><code>PWDict</code></a>, <a href="#Air.PWSet"><code>PWSet</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; d = PWSet{Symbol}(:a =&gt; 1.0, :b =&gt; 2.0, :c =&gt; 3.0)
PWSet{Symbol,Float64} with 3 elements:
  :c
  :b
  :a

julia&gt; setweight(d, :a, 4.0)
PWSet{Symbol,Float64} with 3 elements:
  :a
  :c
  :b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/pheap.jl#LL190-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.take-Union{Tuple{Promise{T}}, Tuple{T}} where T" href="#Air.take-Union{Tuple{Promise{T}}, Tuple{T}} where T"><code>Air.take</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">take(promise)</code></pre><p>Yields the value delivered to the given <code>Promise</code> object after suspending the current thread to wait for the value if necessary.</p><p>See also <a href="#Air.Promise"><code>Promise</code></a>, <code>Base.put!</code>.</p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; p = Promise()
Promise{Any}(&lt;...&gt;)

julia&gt; put!(p, :done)
:done

julia&gt; p
Promise{Any}(:done)

julia&gt; take(p)
:done</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/util.jl#LL371-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.tx-Tuple{F} where F&lt;:Function" href="#Air.tx-Tuple{F} where F&lt;:Function"><code>Air.tx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tx(fn)</code></pre><p>Runs the given function in a transaction and yields the result. The function fn is called as <code>fn()</code> without arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL616-L621">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.tx_actordata-Union{Tuple{Actor{T}}, Tuple{T}} where T" href="#Air.tx_actordata-Union{Tuple{Actor{T}}, Tuple{T}} where T"><code>Air.tx_actordata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tx_actordata(a)</code></pre><p>Yields the in-transaction data for the <code>Actor</code> object <code>a</code>. If <code>a</code> is in an error-state, then throws an <code>ActorException</code>. If there is no transaction currently running, yields <code>nothing</code>.</p><p>This function is considered part of the internal/private interface of <code>Air</code> and shouldn&#39;t generally be called outside of it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL868-L877">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.vars" href="#Air.vars"><code>Air.vars</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vars()</code></pre><p>Yields an <code>IdDict{Var,Any}</code> object that contains a mapping of all <code>Var</code> objects whose current in-task value is not its default value to that <code>Var</code>&#39;s currently assigned value. The dictionary returned by <code>vars</code> may be later restored using the function <code>setvars</code>.</p><p>See also: <a href="#Air.setvars"><code>setvars</code></a>, <a href="#Air.withvars"><code>withvars</code></a>, <a href="#Air.wrapwithvars"><code>wrapwithvars</code></a>, <a href="#Air.Var"><code>Var</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; vars()
IdDict{Var,Any}()</code></pre><pre><code class="language-julia-repl">julia&gt; @var v = :test::Symbol
Var{Symbol}(@h4G6oRR9s: :test; init=:test)

julia&gt; withvars(v =&gt; :temp) do; vars() end
IdDict{Var,Any} with 1 entry:
  Var{Symbol}(@AaE16J5Pic8) =&gt; :temp</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/vars.jl#LL80-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.voldata_finalize-Union{Tuple{Air.VolatileData{T}}, Tuple{T}} where T" href="#Air.voldata_finalize-Union{Tuple{Air.VolatileData{T}}, Tuple{T}} where T"><code>Air.voldata_finalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">voldata_finalize(voldata)</code></pre><p>Calls the finalize function of the given volatile state object (of type <code>VolatileData</code>) if necessary. Yields the new <code>VolatileData</code> object, which may be <code>voldata</code> if there is no finalizer or nothing has changed.</p><p>This function is a private/internal implementation detail of the <code>Air</code> library.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL365-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.withvars" href="#Air.withvars"><code>Air.withvars</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">withvars(f, var1 =&gt; val1, var2 =&gt; val2...)
withvars(f, vardict)</code></pre><p>Runs the function <code>f</code> in a context in which the given <code>Var</code>s have been bound to the given values. In the vase of a dictionary passed as the second argument, the keys must be <code>Var</code> objects. Once the function <code>f</code> has finished running, the <code>Var</code> objects are reverted to their calling-frame values.</p><p>See also: <a href="#Air.Var"><code>Var</code></a>, <a href="#Air.@var-Tuple{Expr}"><code>@var</code></a>, <a href="#Air.vars"><code>vars</code></a>, <a href="#Air.setvars"><code>setvars</code></a>, <a href="#Air.wrapwithvars"><code>wrapwithvars</code></a>, <a href="#Air.wrapsetvars"><code>wrapsetvars</code></a></p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; v = Var{Symbol}(:initval)
Var{Symbol}(@cFgU9Kqe8: :initval; init=:initval)

julia&gt; v[]
:initval

julia&gt; withvars(v =&gt; :newval) do; v[] end
:newval</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/vars.jl#LL114-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.wrapsetvars" href="#Air.wrapsetvars"><code>Air.wrapsetvars</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">wrapsetvars(f, vardict)</code></pre><p>Equivalent to <code>setvars(f, args...)</code> except that instead of running <code>f</code>  immediately in the context of the modified <code>Var</code>s, yields a wrapper around <code>f</code> that, when called, passes all arguments to <code>f</code>, which is run using the given variable bindings in the dictionary <code>vardict</code>.</p><p>See also: <a href="#Air.Var"><code>Var</code></a>, <a href="#Air.@var-Tuple{Expr}"><code>@var</code></a>, <a href="#Air.vars"><code>vars</code></a>, <a href="#Air.withvars"><code>withvars</code></a>, <a href="#Air.setvars"><code>setvars</code></a>, <a href="#Air.wrapwithvars"><code>wrapwithvars</code></a></p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; v = Var{Int}(0)
Var{Int64}(@F6ku5d8: 0; init=0)

julia&gt; v[]
0

julia&gt; vs = withvars(v =&gt; 2) do; vars() end; length(vs)
1

julia&gt; f = wrapsetvars(vs) do x; x + v[] end; f(10)
12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/vars.jl#LL212-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.wrapwithvars" href="#Air.wrapwithvars"><code>Air.wrapwithvars</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">wrapwithvars(f, var1 =&gt; val1, var2 =&gt; val2...)
wrapwithvars(f, vardict)</code></pre><p>Equivalent to <code>withvars(f, args...)</code> except that instead of running <code>f</code>  immediately in the context of the modified <code>Var</code>s, yields a wrapper around <code>f</code> that, when called, passes all arguments to <code>f</code>, which is run using the current variable bindings plus any given bindings. Notable, <code>wrapwithvars(f)</code> will create a wrapped version of <code>f</code> that uses the <code>Var</code> bindings in the current task.</p><p>See also: <a href="#Air.Var"><code>Var</code></a>, <a href="#Air.@var-Tuple{Expr}"><code>@var</code></a>, <a href="#Air.vars"><code>vars</code></a>, <a href="#Air.withvars"><code>withvars</code></a>, <a href="#Air.setvars"><code>setvars</code></a>, <a href="#Air.wrapsetvars"><code>wrapsetvars</code></a></p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; v = Var{Int}(0)
Var{Int64}(@JIm7aUS2sOl: 0; init=0)

julia&gt; v[]
0

julia&gt; f = wrapwithvars(v =&gt; 2) do x; x + v[] end; f(10)
12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/vars.jl#LL178-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, S, Vararg{Any, N} where N}} where {T, N, S}" href="#Base.setindex-Union{Tuple{S}, Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, S, Vararg{Any, N} where N}} where {T, N, S}"><code>Base.setindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setindex(coll, val, index)</code></pre><p>Yields a copy of the given collection <code>coll</code> with the value <code>val</code> set at the given index. This is a persistent version of <code>setindex!</code> and works for most collection types including <code>Array</code>s, <code>Dict</code>s, <code>IdDict</code>s, and Air&#39;s persistent versions of these.</p><p>Note that setindex() <em>always</em> returns a copy of the argument <code>coll</code> or fails. For Air&#39;s persistent collections these operations are efficient, but for the mutable counterparts, they are typically <code>O(n)</code>.</p><p>See also: <code>Base.setindex!</code>, <a href="#Air.push"><code>push</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; setindex((:a,:b,:e,:d), :c, 3)
(:a, :b, :c, :d)</code></pre><pre><code class="language-julia-repl">julia&gt; u = [:a,:b,:e,:d]; v = setindex(u, :c, 3)
4-element Array{Symbol,1}:
 :a
 :b
 :c
 :d

julia&gt; u == v
false

julia&gt; u[3]
:e</code></pre><pre><code class="language-julia-repl">julia&gt; d1 = Dict(); setindex(d1, 10, :a)
Dict{Any,Any} with 1 entry:
  :a =&gt; 10

julia&gt; d1
Dict{Any,Any}()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/api.jl#LL165-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.dropzeros-Union{Tuple{PArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}" href="#SparseArrays.dropzeros-Union{Tuple{PArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>SparseArrays.dropzeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dropzeros(p::PArray)</code></pre><p>Drops explicit values of the given array <code>p</code> that are equal to the array&#39;s default value. This differs from the SparseArrays implementation of dropzeros() only in that <code>PArray</code>s allow arbitrary default values, while <code>SparseArray</code>s allow only the default value of zero.</p><p>Note that under most circumstances, a <code>PArrray</code> will not encode explicit zeros, so this function typically returns the object <code>p</code> untouched.</p><p>See also: <code>SparseArrays.nnz</code>, <code>SparseArrays.findnz</code>, <a href="#Air.PArray"><code>PArray</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air, SparseArrays
end</code></pre><pre><code class="language-julia-repl">julia&gt; u = PVector{Int}([0,1,2,3])
4-element PArray{Int64,1}:
 0
 1
 2
 3

julia&gt; dropzeros(u) === u
true

julia&gt; v = setindex(u, 0, 3)
4-element PArray{Int64,1}:
 0
 1
 0
 3

julia&gt; dropzeros(v) === v
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/parray.jl#LL212-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.findnz-Union{Tuple{PArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}" href="#SparseArrays.findnz-Union{Tuple{PArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>SparseArrays.findnz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findnz(p::PArray)</code></pre><p>Yields the explicitly set elements of the given persistent array <code>p</code>. This method is identical to the typical SparseArrays implementation of findnz() except that it respects the arbitrary default-value that persistent arrays are allowed to have rather than assuming that this value is a zero, as is done in the <code>SparseArray</code>s library.</p><p>Note that under most circumstances, a <code>PArray</code> will not encode explicit zeros, so this function typically returns indices and values for all values that aren&#39;t equal to the default value of the array <code>p</code> (which is zero by default).</p><p>See also: <code>SparseArrays.nnz</code>, <a href="#Air.PArray"><code>PArray</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air, SparseArrays
end</code></pre><pre><code class="language-julia-repl">julia&gt; u = PVector([0,10,20,30])
4-element PArray{Int64,1}:
  0
 10
 20
 30

julia&gt; findnz(u)
([1, 2, 3, 4], [0, 10, 20, 30])</code></pre><pre><code class="language-julia-repl">julia&gt; u = setindex(PVector(0.0, 4), 20, 2)
4-element PArray{Float64,1}:
  0.0
 20.0
  0.0
  0.0

julia&gt; findnz(u)
([2], [20.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/parray.jl#LL262-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.nnz-Union{Tuple{PArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}" href="#SparseArrays.nnz-Union{Tuple{PArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>SparseArrays.nnz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nnz(p::PArray)</code></pre><p>Yields the number of explicitly set values in the persistent array p, regardless of the number that are zero. This is different from the sparse-array library only in that persistent arrays support arbitrary default values instead of supporting only the value zero. Thus this counts explicit values instead of non-zero values.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air, SparseArrays
end</code></pre><pre><code class="language-julia-repl">julia&gt; u = PVector{Int}(0, (4,))
4-element PArray{Int64,1}:
 0
 0
 0
 0

julia&gt; v = setindex(u, 2, 3)
4-element PArray{Int64,1}:
 0
 0
 2
 0

julia&gt; nnz(v)
1

julia&gt; nnz(u)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/parray.jl#LL161-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.nonzeros-Union{Tuple{PArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}" href="#SparseArrays.nonzeros-Union{Tuple{PArray{T, N}}, Tuple{N}, Tuple{T}} where {T, N}"><code>SparseArrays.nonzeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nonzeros(p::PArray)</code></pre><p>Yields the explicitly set values of the given persistent array <code>p</code>. This method is identical to the typical <code>SparseArrays</code> implementation of <code>nonzeros()</code> for  its sparse array classes except that it returns a persistent array of values and that it respects the arbitrary default-value that persistent arrays are allowed to have rather than assuming that this value is a zero, as is done in the <code>SparseArrays</code> library.</p><p>Note that because <code>PArray</code>s don&#39;t typically store values equal to their default value explicitly, this will typically yield a vector of every non-default value in the array.</p><p>See also: <code>SparseArrays.findnz</code>, <code>SparseArrays.nnz</code>, <a href="#Air.PArray"><code>PArray</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air, SparseArrays
end</code></pre><pre><code class="language-julia-repl">julia&gt; u = PVector([0,10,20,30])
4-element PArray{Int64,1}:
  0
 10
 20
 30

julia&gt; nonzeros(u)
4-element PArray{Int64,1}:
  0
 10
 20
 30</code></pre><pre><code class="language-julia-repl">julia&gt; u = setindex(PVector(0.0, 4), 20, 2)
4-element PArray{Float64,1}:
  0.0
 20.0
  0.0
  0.0

julia&gt; nonzeros(u)
1-element PArray{Float64,1}:
 20.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/parray.jl#LL325-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.@delay-Tuple{Expr}" href="#Air.@delay-Tuple{Expr}"><code>Air.@delay</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@delay expression</code></pre><p>Yields a <code>Delay</code> object that matches the given expression. The expression may be one of the following:</p><ol><li>A function of no arguments, such as <code>() -&gt; 10</code>; in this case the delay is made from this function (i.e., the RHS is the <code>-&gt;</code> expression that is delayed).</li><li>A function with a set of symbol arguments evaluates the RHS but uses a let statement to wrap all the symbols in the LHS into a closure.</li><li>An expression, which is treated as equivalent to <code>() -&gt; expression</code>.</li></ol><p>Optionally, the expression or LHS may be tagged with a type T. In this case, a <code>Delay{T}</code> object is yielded instead of a <code>Delay{Any}</code>.</p><p>See also: <a href="#Air.Delay"><code>Delay</code></a>, <a href="#Air.LazyDict"><code>LazyDict</code></a></p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; # Create a Delay with a long run time.
       d = (@delay (println(&quot;Running.&quot;); sleep(2); 10)::Int64)
Delay{Int64}(&lt;...&gt;)

julia&gt; # Start a few threads, each of which attempt to read it. The function will
       # only run once.
       for th in [(Threads.@spawn d[]) for _ in 1:5]; wait(th) end
Running.

julia&gt; # Ensure that it produced the correct value and doesn&#39;t run again.
       d[]
10

julia&gt; # The display now shows the realized value also.
       d
Delay{Int64}(10)

julia&gt; # Create a Delay with a locally-bound symbol.
       d2 = (@delay (d) -&gt; (d[] / 20.0)::Float64)
Delay{Float64}(&lt;...&gt;)

julia&gt; # We can rebind d without affecting d2.
       d = 10
10

julia&gt; d2[]
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/util.jl#LL73-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.@memoize-Tuple{Expr}" href="#Air.@memoize-Tuple{Expr}"><code>Air.@memoize</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@memoize name(args...) = expr
@memoize name(args...) where {...} = expr</code></pre><p><code>@memoize</code> is a macro for declaring that the function declaration that follows should be memoized in a private dictionary and any pre-calculated value should be returned from that dictionary instead of being recalculated. All memoization is thread-safe: <code>expr</code> is only ever evaluated by one thread at a time, and is only ever evaluated once per unique set of arguments.</p><p>Note that arguments are memoized according to equality, so the use of mutable arguments can result in undefined behavior of those arguments are later changed.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; @memoize fib(n::Int) = begin
           println(&quot;Calculating fib($n)...&quot;)
           if n &lt; 1
               return 0
           elseif n == 1
               return 1
           else
               return fib(n-1) + fib(n - 2)
           end
       end::Int
fib (generic function with 1 method)

julia&gt; fib(5)
Calculating fib(5)...
Calculating fib(4)...
Calculating fib(3)...
Calculating fib(2)...
Calculating fib(1)...
Calculating fib(0)...
5

julia&gt; fib(6)
Calculating fib(6)...
8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/util.jl#LL199-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.@p-Tuple" href="#Air.@p-Tuple"><code>Air.@p</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@p{k1 =&gt; v1, k2 =&gt; v2, ...}
@p[x1, x2, ...]
@p[x1 x2...]
@p(x1, x2, ...)</code></pre><p>Yields a persistent data structure, depending on how the macro is called. This is a shorthand for calling the various constructors directly. The following expressions are equivalent:</p><ul><li><code>@p{k1 =&gt; v1, k2 =&gt; v2, ...}</code> and <code>PDict(k1 =&gt; v1, k2 =&gt; v2, ...)</code></li><li><code>@p[x1, x2, ...]</code> and <code>PVector([x1, x2, ...])</code></li><li><code>@p[x1 x2 ...]</code> and <code>PArray([x1 x2 ...])</code></li><li><code>@p(x1, x2, ...)</code> and <code>PSet([x1, x2, ...]</code></li></ul><p>See also: <a href="#Air.PDict"><code>PDict</code></a>, <a href="#Air.PVector"><code>PVector</code></a>, <a href="#Air.PArray"><code>PArray</code></a>, <a href="#Air.PSet"><code>PSet</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; @p{:a =&gt; 1, :b =&gt; 2, :c =&gt; 3}
PDict{Symbol,Int64} with 3 entries:
  :c =&gt; 3
  :a =&gt; 1
  :b =&gt; 2</code></pre><pre><code class="language-julia-repl">julia&gt; @p[1, 2, 3, 4]
4-element PArray{Int64,1}:
 1
 2
 3
 4</code></pre><pre><code class="language-julia-repl">julia&gt; @p[:q2 :q1; :q3 :q4]
2×2 PArray{Symbol,2}:
 :q2  :q1
 :q3  :q4</code></pre><pre><code class="language-julia-repl">julia&gt; @p(:a, :b, :a, :c)
PSet{Symbol} with 3 elements:
  :c
  :a
  :b</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/Air.jl#LL28-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.@tx-Tuple{Any}" href="#Air.@tx-Tuple{Any}"><code>Air.@tx</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@tx expr</code></pre><p>The macro @tx should be followed by an expression; that expression is run in an atomic transaction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/TX.jl#LL748-L753">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Air.@var-Tuple{Expr}" href="#Air.@var-Tuple{Expr}"><code>Air.@var</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@var</code></pre><p>Convenient syntax for creating a task-local Var object: <code>@var name = initval</code> will construct a <code>Var</code> object with the given initial value. <code>@var name = initval::T</code> will create a <code>Var{T}</code> object.</p><p>See also: <a href="#Air.Var"><code>Var</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-">DocTestSetup = quote
    using Air
end</code></pre><pre><code class="language-julia-repl">julia&gt; @var v = :start_sym
Var{Symbol}(@JIm7aUS2sOl: :start_sym; init=:start_sym)

julia&gt; @var u = :start_sym::Any
Var{Any}(@JIm7aUS2sOl: :start_sym; init=:start_sym)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/noahbenson/Air.jl/blob/01c3bba782ffe2fbd0350e74a20335309ed23e78/src/vars.jl#LL353-L377">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 4 November 2021 01:13">Thursday 4 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
